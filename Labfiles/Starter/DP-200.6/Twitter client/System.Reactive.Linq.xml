<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>System.Reactive.Linq</name>
    </assembly>
    <members>
        <member name="T:System.Reactive.Joins.NamespaceDoc">
            <summary><b>System.Reactive.Joins</b>名前空間には、流れるようなメソッド構文を使用して、監視可能なシーケンス上の結合パターンを表現するために使用されるクラスが含まれています。 </summary>
        </member>
        <member name="T:System.Reactive.Concurrency.VirtualTimeSchedulerExtensions">
            <summary>仮想時間のスケジューリング向けの拡張メソッドのセットを提供します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerExtensions.ScheduleRelative``2(System.Reactive.Concurrency.VirtualTimeSchedulerBase{``0,``1},``1,System.Action)">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TAbsolute">絶対時間表現タイプ。</typeparam>
            <typeparam name="TRelative">相対時間表現タイプ。</typeparam>
            <param name="scheduler">アクションを実行する Scheduler。</param>
            <param name="dueTime">その後にアクションを実行する相対時間。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> または <paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerExtensions.ScheduleAbsolute``2(System.Reactive.Concurrency.VirtualTimeSchedulerBase{``0,``1},``0,System.Action)">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TAbsolute">絶対時間表現タイプ。</typeparam>
            <typeparam name="TRelative">相対時間表現タイプ。</typeparam>
            <param name="scheduler">アクションを実行する Scheduler。</param>
            <param name="dueTime">アクションを実行する絶対時間。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> または <paramref name="action"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute">
            <summary>クエリ メソッドの式ツリー形式を提供する静的クラスに適用される属性。これを該当するメソッドにマッピングして、特定のターゲット クラスのタイプでローカル クエリを実行します。</summary>
        </member>
        <member name="M:System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute.#ctor(System.Type)">
            <summary>指定したローカル実行クエリ メソッドの実装タイプに新しいマッピングを作成します。</summary>
            <param name="targetType">ローカル実行のクエリ メソッドがあるタイプ。</param>
        </member>
        <member name="P:System.Reactive.Linq.LocalQueryMethodImplementationTypeAttribute.TargetType">
            <summary>ローカル クエリ メソッドの実装を含むタイプを取得します。</summary>
        </member>
        <member name="T:System.Reactive.Linq.Observable">
            <summary>監視可能なシーケンスに対してメモリ内のクエリを記述するための一連の静的メソッドを提供します。</summary>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0})">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、シーケンスが終了したときに通知を受け取る Task オブジェクトを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <returns>シーケンスの終了を通知するタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0},System.Threading.CancellationToken)">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、シーケンスが終了したときに通知を受け取る Task オブジェクトを返します。指定されたキャンセル トークンを設定することで、ループを途中で終了できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <param name="cancellationToken">ループを停止するために使用されるキャンセル トークン。</param>
            <returns>シーケンスの終了を通知するタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>監視可能なシーケンスで各要素に対するアクションを呼び出し、要素のインデックスを組み込み、シーケンスが終了したときに通知を受け取る Task オブジェクトを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <returns>シーケンスの終了を通知するタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEachAsync``1(System.IObservable{``0},System.Action{``0,System.Int32},System.Threading.CancellationToken)">
            <summary>監視可能なシーケンスで各要素に対するアクションを呼び出し、要素のインデックスを組み込み、シーケンスが終了したときに通知を受け取る Task オブジェクトを返します。指定されたキャンセル トークンを設定することで、ループを途中で終了できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <param name="cancellationToken">ループを停止するために使用されるキャンセル トークン。</param>
            <returns>シーケンスの終了を通知するタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Case``2(System.Func{``0},System.Collections.Generic.IDictionary{``0,System.IObservable{``1}},System.IObservable{``1})">
            <summary><paramref name="selector"/> を使用して <paramref name="sources"/> で返すソースを決定し、一致するものが見つからなければ <paramref name="defaultSource"/> を選択します。</summary>
            <typeparam name="TValue">選択関数によって返される値のタイプ。結果のソースを検索するために使用されます。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="selector"><paramref name="sources"/> 辞書で検索するソースを決定するために呼び出される選択関数。</param>
            <param name="sources"><paramref name="selector"/> 呼び出し結果に基づく選択元のソースの辞書。</param>
            <param name="defaultSource">一致するソースが <paramref name="sources"/> で見つからない場合に選択する既定のソース。</param>
            <returns><paramref name="selector"/> 呼び出し結果に基づいて <paramref name="sources"/> 辞書から取得した監視可能なシーケンス。または一致するものがない場合は <paramref name="defaultSource"/>。  </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> または <paramref name="sources"/> あるいは <paramref name="defaultSource"/> は null です。 </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Case``2(System.Func{``0},System.Collections.Generic.IDictionary{``0,System.IObservable{``1}},System.Reactive.Concurrency.IScheduler)">
            <summary><paramref name="selector"/> を使用して <paramref name="sources"/> で返すソースを決定し、一致するものが見つからない場合は指定した Scheduler で空のシーケンスを選択します。</summary>
            <typeparam name="TValue">選択関数によって返される値のタイプ。結果のソースを検索するために使用されます。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="selector"><paramref name="sources"/> 辞書で検索するソースを決定するために呼び出される選択関数。</param>
            <param name="sources"><paramref name="selector"/> 呼び出し結果に基づく選択元のソースの辞書。</param>
            <param name="scheduler">一致するソースが <paramref name="sources"/> で見つからない場合に空のシーケンスを生成する Scheduler。</param>
            <returns><paramref name="selector"/> 呼び出し結果に基づいて <paramref name="sources"/> 辞書から取得した監視可能なシーケンス。または一致するものが見つからない場合は空のシーケンス。 </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> または <paramref name="sources"/> あるいは <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Case``2(System.Func{``0},System.Collections.Generic.IDictionary{``0,System.IObservable{``1}})">
            <summary><paramref name="selector"/> を使用して <paramref name="sources"/> をで返すソースを決定し、一致するものが見つからない場合は空のシーケンスを選択します。</summary>
            <typeparam name="TValue">選択関数によって返される値のタイプ。結果のソースを検索するために使用されます。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="selector"><paramref name="sources"/> 辞書で検索するソースを決定するために呼び出される選択関数。</param>
            <param name="sources"><paramref name="selector"/> 呼び出し結果に基づく選択元のソースの辞書。</param>
            <returns><paramref name="selector"/> 呼び出し結果に基づいて <paramref name="sources"/> 辞書から取得した監視可能なシーケンス。または一致するものが見つからない場合は空のシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> または <paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DoWhile``1(System.IObservable{``0},System.Func{System.Boolean})">
            <summary>指定された <paramref name="condition"/> が保持されている限り、特定の <paramref name="source"/> を繰り返し、<paramref name="source"/> の繰り返しが完了するたびに <paramref name="condition"/> が評価されます。  </summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source"><paramref name="condition"/> 関数が true と評価する限り繰り返すソース。</param>
            <param name="condition">ソースの繰り返しが必要かどうか判定するため、<paramref name="source"/> によって繰り返しの完了後に評価される条件。</param>
            <returns><paramref name="condition"/> が保持される限り、<paramref name="source"/>シーケンスを連結して得られる監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="condition"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.For``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>特定の列挙可能な <paramref name="source"/> で各要素の <paramref name="resultSelector"/> を実行することによって得られる監視可能なシーケンスを連結します。</summary>
            <typeparam name="TSource">列挙可能なソース シーケンスの要素のタイプ。</typeparam>
            <typeparam name="TResult">監視可能な結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">各要素が、結果シーケンスで連結される監視可能なソースにマップされる列挙可能なソース。</param>
            <param name="resultSelector"><paramref name="source"/> で各要素の監視可能なソースを選択する関数。</param>
            <returns><paramref name="source"/> の各要素に対して <paramref name="resultSelector"/> で返されるソースを連結することによって得られる監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0},System.IObservable{``0})">
            <summary>指定した <paramref name="condition"/> が true と評価される場合は、<paramref name="thenSource"/> シーケンスを選択します。  それ以外の場合は、<paramref name="elseSource"/> シーケンスを選択します。</summary>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="condition">返すシーケンスを決定するために評価される条件。</param>
            <param name="thenSource"><paramref name="condition"/> が true と評価した場合に返されるシーケンス。</param>
            <param name="elseSource"><paramref name="condition"/> が false と評価した場合に返されるシーケンス。</param>
            <returns><paramref name="thenSource"/> <paramref name="condition"/> が true と評価した場合。それ以外は <paramref name="elseSource"/>。 </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="thenSource"/> あるいは <paramref name="elseSource"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0})">
            <summary>指定した <paramref name="condition"/> が true と評価される場合は、<paramref name="thenSource"/> シーケンスを選択します。それ以外の場合は、空のシーケンスを返します。</summary>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="condition">返すシーケンスを決定するために評価される条件。</param>
            <param name="thenSource"><paramref name="condition"/> が true と評価した場合に返されるシーケンス。</param>
            <returns><paramref name="thenSource"/> <paramref name="condition"/> が true と評価する場合。それ以外は空のシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="thenSource"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.If``1(System.Func{System.Boolean},System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定した <paramref name="condition"/> が true と評価される場合は、<paramref name="thenSource"/> シーケンスを選択します。それ以外の場合は、指定された Scheduler で生成された空のシーケンスを返します。</summary>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="condition">返すシーケンスを決定するために評価される条件。</param>
            <param name="thenSource"><paramref name="condition"/> が true と評価した場合に返されるシーケンス。</param>
            <param name="scheduler"><paramref name="condition"/> が false と評価した場合に空のシーケンス を生成する Scheduler。</param>
            <returns><paramref name="thenSource"/> <paramref name="condition"/> が true と評価する場合。それ以外は空のシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="thenSource"/> あるいは <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.While``1(System.Func{System.Boolean},System.IObservable{``0})">
            <summary>指定された <paramref name="condition"/> が保持されている限り、特定の <paramref name="source"/> を繰り返し、繰り返される各 <paramref name="source"/> がサブスクライブされる前に <paramref name="condition"/> が評価されます。  </summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source"><paramref name="condition"/> 関数が true と評価する限り繰り返すソース。</param>
            <param name="condition">ソースの繰り返しが必要かどうか判定するため、<paramref name="source"/> にサブスクライブする前に評価される条件。</param>
            <returns><paramref name="condition"/> が保持される限り、<paramref name="source"/>シーケンスを連結して得られる監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TResult">終了デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">開始デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TResult">終了デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``5(System.Func{``0,``1,``2,``3,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``4})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``6(System.Func{``0,``1,``2,``3,``4,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``5})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``7(System.Func{``0,``1,``2,``3,``4,``5,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``6})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``8(System.Func{``0,``1,``2,``3,``4,``5,``6,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``7})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``8})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``9})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``10})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``11})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``12})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">begin デリゲートに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``13})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">begin デリゲートに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">begin デリゲートに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``14})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">begin デリゲートに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">begin デリゲートに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">begin デリゲートに渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">end デリゲートによって返される結果のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、監視可能なシーケンスとして結果を取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``4(System.Func{``0,``1,``2,``3,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``5(System.Func{``0,``1,``2,``3,``4,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``6(System.Func{``0,``1,``2,``3,``4,``5,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``7(System.Func{``0,``1,``2,``3,``4,``5,``6,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">begin デリゲートに渡される 12 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">begin デリゲートに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">begin デリゲートに渡される 13 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsyncPattern``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult})">
            <summary>Begin/End 呼び出し関数のペアを非同期関数に変換します。</summary>
            <typeparam name="TArg1">begin デリゲートに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">begin デリゲートに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">begin デリゲートに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">begin デリゲートに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">begin デリゲートに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">begin デリゲートに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">begin デリゲートに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">begin デリゲートに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">begin デリゲートに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">begin デリゲートに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">begin デリゲートに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">begin デリゲートに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">begin デリゲートに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">begin デリゲートに渡される 14 番目の引数のタイプ。</typeparam>
            <param name="begin">非同期操作を開始するデリゲート。</param>
            <param name="end">非同期操作を終了するデリゲート。</param>
            <returns>非同期操作を開始し、結果 (Unit 値として表される) を監視可能なシーケンスとして取得するために使用できる関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="begin"/> または <paramref name="end"/> は null です。</exception>
            <remarks>その結果の関数を呼び出すたびに非同期操作が開始されます。結果のシーケンスへのサブスクリプションには、監視可能な副作用はなく、各サブスクリプションは非同期操作の結果を生成します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0})">
            <summary>指定した関数を非同期に呼び出し、監視可能なシーケンスを通じて結果を明らかにします。</summary>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期で実行する関数。</param>
            <returns>関数の結果値または例外を公開する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>この関数は、結果のシーケンスのサブスクリプション中ではなく、直ちに呼び出されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、関数の結果を監視できます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定した Scheduler で指定された関数を非同期に呼び出し、監視可能なシーケンスを通じて結果を明らかにします</summary>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期で実行する関数。</param>
            <param name="scheduler">関数を実行する Scheduler。</param>
            <returns>関数の結果値または例外を公開する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>この関数は、結果シーケンスのサブスクリプション中ではなく、直ちに呼び出されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、関数の結果を監視できます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>非同期関数を呼び出し、監視可能なシーケンスを通じて結果を明らかにします。</summary>
            <typeparam name="TResult">非同期関数によって返される結果のタイプ。</typeparam>
            <param name="functionAsync">実行する非同期関数。</param>
            <returns>関数の結果値または例外を公開する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>この関数は、結果のシーケンスのサブスクリプション中ではなく、直ちに開始されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、関数の結果を監視できます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>非同期関数を呼び出し、監視可能なシーケンスを通じて結果を明らかにします。CancellationToken は、結果として得られる監視可能なシーケンス上のすべてのサブスクリプションによって共有されます。詳細については、解説セクションを参照してください。</summary>
            <typeparam name="TResult">非同期関数によって返される結果のタイプ。</typeparam>
            <param name="functionAsync">実行する非同期関数。</param>
            <returns>関数の結果値または例外を公開する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>この関数は、結果のシーケンスのサブスクリプション中ではなく、直ちに開始されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、関数の結果を監視できます。</description></item>
            <item><description>結果のシーケンスに対するサブスクリプションが破棄されると、CancellationToken が設定されます。破棄されたサブスクリプションに関連付けられているオブザーバーには TaskCanceledException は表示されませんが、他のオブザーバーには表示されます。Catch 演算子を使用すると、これを防ぐことができます。この動作のため、結果のシーケンスを配布する場合は注意が必要です。最も一般的な用途は、結果のシーケンスに対する単一のサブスクリプションを持つことです。これは CancellationToken 状態を制御します。また、マルチキャスト演算子を使用してサブスクリプションの動作を制御することもできます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start(System.Action)">
            <summary>アクションを非同期に呼び出し、監視可能なシーケンスを通じて結果を明らかにします。</summary>
            <param name="action">非同期で実行するアクション。</param>
            <returns>アクションの完了時に Unit 値を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>このアクションは、結果のシーケンスのサブスクリプション中ではなく、直ちに呼び出されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、アクションの結果を監視できます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Start(System.Action,System.Reactive.Concurrency.IScheduler)">
            <summary>指定した Scheduler でアクションを非同期に呼び出し、監視可能なシーケンスを通じて結果を明らかにします。</summary>
            <param name="action">非同期で実行するアクション。</param>
            <param name="scheduler">アクションを実行する Scheduler。</param>
            <returns>アクションの完了時に Unit 値を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>このアクションは、結果のシーケンスのサブスクリプション中ではなく、直ちに呼び出されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、アクションの結果を監視できます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>非同期アクションを呼び出し、監視可能なシーケンスを通じて結果を明らかにします。</summary>
            <param name="actionAsync">実行する非同期アクション。</param>
            <returns>アクションの完了時に Unit 値を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>アクションは、結果のシーケンスのサブスクリプション中ではなく、直ちに開始されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、アクションの結果を監視できます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartAsync(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>非同期アクションを呼び出し、監視可能なシーケンスを通じて結果を明らかにします。CancellationToken は、結果として得られる監視可能なシーケンス上のすべてのサブスクリプションによって共有されます。詳細については、解説セクションを参照してください。</summary>
            <param name="actionAsync">実行する非同期アクション。</param>
            <returns>アクションの完了時に Unit 値を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> は null です。</exception>
            <remarks>
            <list type="bullet">
            <item><description>アクションは、結果のシーケンスのサブスクリプション中ではなく、直ちに開始されます。</description></item>
            <item><description>結果のシーケンスに対する複数のサブスクリプションは、アクションの結果を監視できます。</description></item>
            <item><description>結果のシーケンスに対するサブスクリプションが破棄されると、CancellationToken が設定されます。破棄されたサブスクリプションに関連付けられているオブザーバーには TaskCanceledException は表示されませんが、他のオブザーバーには表示されます。Catch 演算子を使用すると、これを防ぐことができます。この動作のため、結果のシーケンスを配布する場合は注意が必要です。最も一般的な用途は、結果のシーケンスに対する単一のサブスクリプションを持つことです。これは CancellationToken 状態を制御します。また、マルチキャスト演算子を使用してサブスクリプションの動作を制御することもできます。</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>非同期関数を監視可能なシーケンスに変換します。結果のシーケンスに対する各サブスクリプションにより、関数が開始されます。</summary>
            <typeparam name="TResult">非同期関数によって返される結果のタイプ。</typeparam>
            <param name="functionAsync">変換する非同期関数。</param>
            <returns>関数を呼び出した結果を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})">
            <summary>非同期関数に変換して、監視可能なシーケンスに変換します。結果のシーケンスに対する各サブスクリプションにより、関数が開始されます。非同期関数に渡される CancellationToken は、関数の呼び出しをトリガーした監視可能なシーケンスのサブスクリプションに関連付けられ、ベスト エフォートの取り消しに使用できます。</summary>
            <typeparam name="TResult">非同期関数によって返される結果のタイプ。</typeparam>
            <param name="functionAsync">変換する非同期関数。</param>
            <returns>関数を呼び出した結果を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionAsync"/> は null です。</exception>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、非同期関数に供給された CancellationToken が通知されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>非同期アクションを監視可能なシーケンスに変換します。結果のシーケンスに対する各サブスクリプションにより、アクションが開始されます。</summary>
            <param name="actionAsync">変換する非同期アクション。</param>
            <returns>アクションの完了時に Unit 値を公開する監視可能なシーケンス、または例外。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromAsync(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>非同期アクションを監視可能なシーケンスに変換します。結果のシーケンスに対する各サブスクリプションにより、アクションが開始されます。非同期アクションに渡される CancellationToken は、アクションの呼び出しをトリガーした監視可能なシーケンスのサブスクリプションに関連付けられ、ベスト エフォートの取り消しに使用できます。</summary>
            <param name="actionAsync">変換する非同期アクション。</param>
            <returns>アクションの完了時に Unit 値を公開する監視可能なシーケンス、または例外。</returns>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、非同期関数に供給された CancellationToken が通知されます。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="actionAsync"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Func{``0})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Func{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Func{``0,``1})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Func{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Func{``0,``1,``2})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Func{``0,``1,``2},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Func{``0,``1,``2,``3})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Func{``0,``1,``2,``3},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Func{``0,``1,``2,``3,``4})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Func{``0,``1,``2,``3,``4},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Func{``0,``1,``2,``3,``4,``5},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Func{``0,``1,``2,``3,``4,``5,``6},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">関数に渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">関数に渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">関数に渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">関数に渡される 15 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">関数に渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">関数に渡される 15 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16})">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">関数に渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">関数に渡される 15 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg16">関数に渡される 16 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期関数に変換します。結果として得られる非同期関数を呼び出すたびに、指定された Scheduler で元の同期関数が呼び出されます。</summary>
            <typeparam name="TArg1">関数に渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">関数に渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">関数に渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">関数に渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">関数に渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">関数に渡された 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">関数に渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">関数に渡された 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">関数に渡された 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">関数に渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">関数に渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">関数に渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">関数に渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">関数に渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">関数に渡される 15 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg16">関数に渡される 16 番目の引数のタイプ。</typeparam>
            <typeparam name="TResult">関数によって返される結果のタイプ。</typeparam>
            <param name="function">非同期関数に変換する関数。</param>
            <param name="scheduler">元の関数を呼び出す Scheduler。</param>
            <returns>非同期関数。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="function"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync(System.Action)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync(System.Action,System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Action{``0})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``1(System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Action{``0,``1})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``2(System.Action{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Action{``0,``1,``2})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``3(System.Action{``0,``1,``2},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Action{``0,``1,``2,``3})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``4(System.Action{``0,``1,``2,``3},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Action{``0,``1,``2,``3,``4})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``5(System.Action{``0,``1,``2,``3,``4},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Action{``0,``1,``2,``3,``4,``5})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``6(System.Action{``0,``1,``2,``3,``4,``5},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Action{``0,``1,``2,``3,``4,``5,``6})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``7(System.Action{``0,``1,``2,``3,``4,``5,``6},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡された 8 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">アクションに渡される 14 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">アクションに渡される 14 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">アクションに渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">アクションに渡される 15 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">アクションに渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">アクションに渡される 15 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、既定の Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">アクションに渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">アクションに渡される 15 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg16">アクションに渡される 16 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToAsync``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},System.Reactive.Concurrency.IScheduler)">
            <summary>関数を非同期アクションに変換します。結果として得られる非同期アクションを呼び出すたびに、指定された Scheduler に対する元の同期アクションが呼び出されます。</summary>
            <typeparam name="TArg1">アクションに渡される最初の引数のタイプ。</typeparam>
            <typeparam name="TArg2">アクションに渡される 2 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg3">アクションに渡される 3 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg4">アクションに渡される 4 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg5">アクションに渡される 5 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg6">アクションに渡される 6 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg7">アクションに渡される 7 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg8">アクションに渡される 8 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg9">アクションに渡される 9 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg10">アクションに渡される 10 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg11">アクションに渡される 11 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg12">アクションに渡される 12 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg13">アクションに渡される 13 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg14">アクションに渡される 14 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg15">アクションに渡される 15 番目の引数のタイプ。</typeparam>
            <typeparam name="TArg16">アクションに渡される 16 番目の引数のタイプ。</typeparam>
            <param name="action">非同期アクションに変換するアクション。</param>
            <param name="scheduler">元のアクションを呼び出す Scheduler。</param>
            <returns>非同期アクション。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Action{System.EventHandler},System.Action{System.EventHandler})">
            <summary><see cref="T:System.EventHandler"/> に基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部にリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Action{System.EventHandler},System.Action{System.EventHandler},System.Reactive.Concurrency.IScheduler)">
            <summary><see cref="T:System.EventHandler"/> に基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部にリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Action{``0},System.Action{``0})">
            <summary>提供されたイベント デリゲートのタイプに基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部にリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>提供されたイベント デリゲートのタイプに基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0})">
            <summary><see cref="T:System.EventHandler`1"/> に基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="conversion">基になる .NET イベントと互換性のあるデリゲートに特定のイベント ハンドラーを変換するために使用される関数。結果のデリゲートは、addHandler および removeHandler アクション パラメーターの呼び出しで使用されます。</param>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> または <paramref name="addHandler"/> あるいは <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部にリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Func{System.EventHandler{``1},``0},System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary><see cref="T:System.EventHandler`1"/> に基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="conversion">基になる .NET イベントと互換性のあるデリゲートに特定のイベント ハンドラーを変換するために使用される関数。結果のデリゲートは、addHandler および removeHandler アクション パラメーターの呼び出しで使用されます。</param>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> または <paramref name="addHandler"/> あるいは <paramref name="removeHandler"/> もしくは <paramref name="scheduler"/> は null です。  </exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``3(System.Action{``0},System.Action{``0})">
            <summary>厳密に型指定されたセンダー パラメーターのある指定イベント デリゲートのタイプに基づいて、標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``3(System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>厳密に型指定されたセンダー パラメーターのある指定イベント デリゲートのタイプに基づいて、標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Action{System.EventHandler{``0}},System.Action{System.EventHandler{``0}})">
            <summary><see cref="T:System.EventHandler`1"/> に基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Action{System.EventHandler{``0}},System.Action{System.EventHandler{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary><see cref="T:System.EventHandler`1"/> に基づいて標準の .NET イベント パターンに準拠した .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Object,System.String)">
            <summary><see cref="T:System.EventArgs"/> パラメーターを使用して標準の .NET イベント パターンに準拠したインスタンス .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、ターゲット オブジェクトのタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <param name="target">変換するイベントを公開するオブジェクト インスタンス。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> または <paramref name="eventName"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Object,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary><see cref="T:System.EventArgs"/> パラメーターを使用して標準の .NET イベント パターンに準拠したインスタンス .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、ターゲット オブジェクトのタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <param name="target">変換するイベントを公開するオブジェクト インスタンス。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> または <paramref name="eventName"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Object,System.String)">
            <summary>厳密に型指定されたイベント引数を持つ標準の .NET イベント パターンに準拠して、インスタンス .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、ターゲット オブジェクトのタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="target">変換するイベントを公開するオブジェクト インスタンス。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> または <paramref name="eventName"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Object,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>厳密に型指定されたイベント引数を持つ標準の .NET イベント パターンに準拠して、インスタンス .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、ターゲット オブジェクトのタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="target">変換するイベントを公開するオブジェクト インスタンス。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> または <paramref name="eventName"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Object,System.String)">
            <summary>厳密に型指定されたセンダーと厳密に型指定されたイベント引数のある標準の .NET イベント パターンに準拠して、インスタンス .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、ターゲット オブジェクトのタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="target">変換するイベントを公開するオブジェクト インスタンス。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> または <paramref name="eventName"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの最初の引数タイプは TSender に割り当てることができません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Object,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>厳密に型指定されたセンダーと厳密に型指定されたイベント引数のある標準の .NET イベント パターンに準拠して、インスタンス .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、ターゲット オブジェクトのタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="target">変換するイベントを公開するオブジェクト インスタンス。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="target"/> または <paramref name="eventName"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの最初の引数タイプは TSender に割り当てることができません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Type,System.String)">
            <summary><see cref="T:System.EventArgs"/> パラメーターのある標準の .NET イベント パターンに準拠して、静的な .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、指定されたタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <param name="type">変換する静的イベントを公開するタイプ。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> または <paramref name="eventName"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern(System.Type,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary><see cref="T:System.EventArgs"/> パラメーターのある標準の .NET イベント パターンに準拠して、静的な .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、指定されたタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <param name="type">変換する静的イベントを公開するタイプ。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> または <paramref name="eventName"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Type,System.String)">
            <summary>厳密に型指定されたイベント引数のある標準の .NET イベント パターンに準拠して、静的な .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、指定されたタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="type">変換する静的イベントを公開するタイプ。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> または <paramref name="eventName"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``1(System.Type,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>厳密に型指定されたイベント引数のある標準の .NET イベント パターンに準拠して、静的な .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、指定されたタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="type">変換する静的イベントを公開するタイプ。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> または <paramref name="eventName"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Type,System.String)">
            <summary>厳密に型指定されたセンダーと厳密に型指定されたイベント引数のある標準の .NET イベント パターンに準拠して、静的な .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、指定されたタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="type">変換する静的イベントを公開するタイプ。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> または <paramref name="eventName"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの最初の引数タイプは TSender に割り当てることができません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEventPattern の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern を呼び出す時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラーの呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEventPattern``2(System.Type,System.String,System.Reactive.Concurrency.IScheduler)">
            <summary>厳密に型指定されたセンダーと厳密に型指定されたイベント引数のある標準の .NET イベント パターンに準拠して、静的な .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。リフレクションは、指定されたタイプと指定されたイベント名に基づいてイベントを検出するために使用されます。標準の .NET イベント パターンに準拠しないイベントを変換するには、代わりに FromEvent オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="type">変換する静的イベントを公開するタイプ。</param>
            <param name="eventName">変換するイベントの名前。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しのデータ表現を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> または <paramref name="eventName"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">イベントが見つかりませんでした。- または - イベントが標準の .NET イベント パターンに準拠していません。- または - イベントの最初の引数タイプは TSender に割り当てることができません。- または - イベントの 2 番目の引数タイプは TEventArgs に割り当てることができません。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEventPattern 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEventPattern のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Func{System.Action{``1},``0},System.Action{``0},System.Action{``0})">
            <summary>変換関数を使用してイベント デリゲートを取得し、.NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="conversion">基になる .NET イベントと互換性のあるデリゲートに特定のイベント ハンドラーを変換するために使用される関数。結果のデリゲートは、addHandler および removeHandler アクション パラメーターの呼び出しで使用されます。</param>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> または <paramref name="addHandler"/> あるいは <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEvent の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEvent の呼び出し時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラー呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEvent 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Func{System.Action{``1},``0},System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>変換関数を使用してイベント デリゲートを取得し、.NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="conversion">基になる .NET イベントと互換性のあるデリゲートに特定のイベント ハンドラーを変換するために使用される関数。結果のデリゲートは、addHandler および removeHandler アクション パラメーターの呼び出しで使用されます。</param>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="conversion"/> または <paramref name="addHandler"/> あるいは <paramref name="removeHandler"/> もしくは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>イベント ストリーム クエリ式の外部で FromEvent 呼び出しをリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEvent のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Action{``0},System.Action{``0})">
            <summary>提供されたイベント デリゲート タイプを使用して、.NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEvent の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEvent の呼び出し時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラー呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEvent 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``2(System.Action{``0},System.Action{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>提供されたイベント デリゲート タイプを使用して、.NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TDelegate">変換するイベントのデリゲートのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>イベント ストリーム クエリ式の外部で FromEvent 呼び出しをリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEvent のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``1(System.Action{System.Action{``0}},System.Action{System.Action{``0}})">
            <summary>汎用アクション ベースの .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEvent の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEvent の呼び出し時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラー呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEvent 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent``1(System.Action{System.Action{``0}},System.Action{System.Action{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>汎用アクション ベースの .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>イベント ストリーム クエリ式の外部で FromEvent 呼び出しをリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEvent のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent(System.Action{System.Action},System.Action{System.Action})">
            <summary>アクション ベースの .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>現在の <see cref="T:System.Threading.SynchronizationContext"/> は FromEvent の呼び出し中にキャプチャされ、ハンドラー呼び出しの事後追加・削除に使用されます。この動作により、同じコンテキストから thread-affine  イベント向けのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>FromEvent の呼び出し時点で SynchronizationContext が存在しない場合、Subscribe または Dispose 呼び出しを行うスレッドで、ハンドラー呼び出しの追加と削除が同期的に行われます。</para>
            <para>Reactive Extensions のフリー スレッドの性質上、FromEvent 呼び出しをイベント ストリーム クエリ式の外部でリフトすることをお勧めします。これにより、キャプチャされた SynchronizationContext が予測可能になります。このベスト プラクティスでは、クエリ内の煩雑なコードのブリッジが減り、クエリ式がより簡潔でわかりやすくなります。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FromEvent(System.Action{System.Action},System.Action{System.Action},System.Reactive.Concurrency.IScheduler)">
            <summary>アクション ベースの .NET イベントを監視可能なシーケンスに変換します。各イベント呼び出しは、結果のシーケンスで OnNext メッセージを介して表示されます。標準の .NET イベント パターンに準拠するイベントを変換するには、代わりに FromEventPattern オーバーロードのいずれかを使用します。</summary>
            <param name="addHandler">基になる .NET イベントに特定のイベント ハンドラーを接続するアクション。</param>
            <param name="removeHandler">基になる .NET イベントから特定のイベント ハンドラーを切り離すアクション。</param>
            <param name="scheduler">イベント ハンドラーの追加と削除ロジックを実行する Scheduler。</param>
            <returns>基になる .NET イベントの呼び出しに渡されるイベント引数オブジェクトを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="addHandler"/> または <paramref name="removeHandler"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>オブザーバーの数が 0 を超えるたびに、ハンドラーの呼び出しを追加および削除します。そのため、イベント ハンドラーは、マルチキャストのサブジェクトを使用して、同時にアクティブな複数のオブザーバーによって共有される場合があります。</para>
            <para>ハンドラー呼び出しの追加および削除は、指定された Scheduler で実行されます。この動作により、同じコンテキストから thread-affine  イベントのハンドラー追加・削除操作にアクセスできます。これは一部の UI フレームワークで必要です。</para>
            <para>イベント ストリーム クエリ式の外部で FromEvent 呼び出しをリフトすることをお勧めします。このベスト プラクティスはクエリ内の煩雑なコードのブリッジを減らすため、クエリ式がより簡潔で理解しやすくなります。これには、IScheduler パラメーターを省略する FromEvent のオーバーロードに関するさらなる利点があります。詳細については、これらのオーバーロードの解説セクションを参照してください。</para>
            </remarks>
            <seealso cref="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
            <summary>アキュムレータ関数を監視可能なシーケンスに適用し、集計の結果を結果シーケンスで単一の要素として返します。指定されたシード値は、初期アキュムレータ値として使用されます。増分中間結果を含む集計動作については、 <see cref="M:System.Reactive.Linq.Observable.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})"/>を参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TAccumulate">集計の結果のタイプ。</typeparam>
            <param name="source">集計する監視可能なシーケンス。</param>
            <param name="seed">初期アキュムレータ値。</param>
            <param name="accumulator">各要素で呼び出されるアキュムレータ関数。</param>
            <returns>最終的なアキュムレータ値のある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="accumulator"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Aggregate``3(System.IObservable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <summary>アキュムレータ関数を監視可能なシーケンスに適用し、集計の結果を結果シーケンスで単一の要素として返します。指定されたシード値が初期アキュムレータ値として使用され、指定された結果選択関数を使用して結果値を選択します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TAccumulate">アキュムレータ値のタイプ。</typeparam>
            <typeparam name="TResult">結果の値のタイプ。</typeparam>
            <param name="source">集計する監視可能なシーケンス。</param>
            <param name="seed">初期アキュムレータ値。</param>
            <param name="accumulator">各要素で呼び出されるアキュムレータ関数。</param>
            <param name="resultSelector">最終的なアキュムレータ値を結果値に変換する関数。</param>
            <returns>最終的なアキュムレータ値のある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="accumulator"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Aggregate``1(System.IObservable{``0},System.Func{``0,``0,``0})">
            <summary>アキュムレータ関数を監視可能なシーケンスに適用し、集計の結果を結果シーケンスで単一の要素として返します。増分中間結果を含む集計動作については、 <see cref="M:System.Reactive.Linq.Observable.Scan``1(System.IObservable{``0},System.Func{``0,``0,``0})"/>を参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプと集計の結果。</typeparam>
            <param name="source">集計する監視可能なシーケンス。</param>
            <param name="accumulator">各要素で呼び出されるアキュムレータ関数。</param>
            <returns>最終的なアキュムレータ値のある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="accumulator"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.All``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>監視可能なシーケンスのすべての要素が条件を満たすかどうかを決定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">述語を適用する要素を持つ監視可能なシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。</param>
            <returns>ソース シーケンス内のすべての要素が指定された述語でテストに合格するかどうかを決定する単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Any``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスに要素が含まれているかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">非空をチェックする監視可能なシーケンス。</param>
            <returns>ソース シーケンスに要素が含まれているかどうかを判別する単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Any``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>監視可能なシーケンスの要素が条件を満たすかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">述語を適用する要素を持つ監視可能なシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。</param>
            <returns>ソース シーケンス内の要素が指定された述語でテストに合格するかどうかを決定する単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Double})">
            <summary><see cref="T:System.Double"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Single})">
            <summary><see cref="T:System.Single"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Decimal})">
            <summary><see cref="T:System.Decimal"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Int32})">
            <summary><see cref="T:System.Int32"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Int64})">
            <summary><see cref="T:System.Int64"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Double}})">
            <summary>Nullable <see cref="T:System.Double"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する Nullable <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Single}})">
            <summary>Nullable <see cref="T:System.Single"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する Nullable <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>Nullable <see cref="T:System.Decimal"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する Nullable <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Int32}})">
            <summary>Nullable <see cref="T:System.Int32"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する Nullable <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きい。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average(System.IObservable{System.Nullable{System.Int64}})">
            <summary>Nullable <see cref="T:System.Int64"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <param name="source">平均を計算する Nullable <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Decimal"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Double"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Single"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Int32"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Int64"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Decimal"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Double"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Single"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Int32"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Average``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Int64"/> 値の監視可能なシーケンスの平均を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">平均を計算する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>値のシーケンスの平均がある単一の要素を含む監視可能なシーケンス、またはソース シーケンスが空の場合、あるいは null の値のみが含まれている場合は null。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Contains``1(System.IObservable{``0},``0)">
            <summary>既定の等値比較関数を使用して、監視可能なシーケンスに指定された要素が含まれているかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を検索する監視可能なシーケンス。</param>
            <param name="value">ソース シーケンス内で検索する値。</param>
            <returns>ソース シーケンスに指定された値を持つ要素が含まれているかどうかを判別する単一の要素を含む観測可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Contains``1(System.IObservable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>指定された System.Collections.Generic.IEqualityComparer&lt;T&gt; を使用して、監視可能なシーケンスに指定された要素が含まれているかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を検索する監視可能なシーケンス。</param>
            <param name="value">ソース シーケンス内で検索する値。</param>
            <param name="comparer">要素を比較する等値比較関数。</param>
            <returns>ソース シーケンスに指定された値を持つ要素が含まれているかどうかを判別する単一の要素を含む観測可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Count``1(System.IObservable{``0})">
            <summary>監視可能なシーケンス内の要素の合計数を表す <see cref="T:System.Int32"/> を含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">カウントする要素を含む監視可能なシーケンス。</param>
            <returns>入力シーケンスで要素の数がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の数が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Count``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>指定した監視可能なシーケンスで要件を満たす要素の数を表す <see cref="T:System.Int32"/> が含まれている監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">カウントする要素を含む監視可能なシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。</param>
            <returns>入力シーケンスで述語関数の条件を満たす要素の数を表す数値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ElementAt``1(System.IObservable{``0},System.Int32)">
            <summary>シーケンス内の指定されたインデックスで要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を返す監視可能なシーケンス。</param>
            <param name="index">取得する要素の 0 から始めるインデックス。</param>
            <returns>ソース シーケンス内の指定された位置で要素を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> は 0 未満です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">(非同期) <paramref name="index"/>は、ソース シーケンス内の要素の数以上です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ElementAtOrDefault``1(System.IObservable{``0},System.Int32)">
            <summary>インデックスが範囲外の場合は、シーケンス内の指定されたインデックスの要素を返すか、既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を返す監視可能なシーケンス。</param>
            <param name="index">取得する要素の 0 から始めるインデックス。</param>
            <returns>ソース シーケンス内の指定された位置で要素を生成する監視可能なシーケンス、またはインデックスがソース シーケンスの境界外にある場合の既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最初の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の最初の要素を含むシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最初の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンスの最初の要素を含むシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) 述語の条件を満たす要素はありません。-または- ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最初の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の最初の要素を含むシーケンス、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最初の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンスの最初の要素を含むシーケンス、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.IsEmpty``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスが空かどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">空かどうかチェックするための監視可能なシーケンス。</param>
            <returns>ソース シーケンスが空かどうかを判別する単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最後の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の最後の要素を含むシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最後の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンス内の最後の要素を含むシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) 述語の条件を満たす要素はありません。-または- ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最後の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の最後の要素を含むシーケンス、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最後の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンス内の最後の要素を含むシーケンス、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LongCount``1(System.IObservable{``0})">
            <summary>監視可能なシーケンス内の要素の合計数を表す <see cref="T:System.Int64"/> を含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">カウントする要素を含む監視可能なシーケンス。</param>
            <returns>入力シーケンスで要素の数がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の数が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LongCount``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>指定した監視可能なシーケンスで要件を満たす要素の数を表す <see cref="T:System.Int64"/> が含まれている監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">カウントする要素を含む監視可能なシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。</param>
            <returns>入力シーケンスで述語関数の条件を満たす要素の数を表す数値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0})">
            <summary>監視可能なシーケンス内の最大要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大要素を決定する監視可能なシーケンス。</param>
            <returns>ソース シーケンス内の最大要素を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>指定された比較関数に従って、監視可能なシーケンス内の最大値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大要素を決定する監視可能なシーケンス。</param>
            <param name="comparer">要素の比較に使用される比較関数。</param>
            <returns>ソース シーケンス内の最大要素を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Double})">
            <summary><see cref="T:System.Double"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Single})">
            <summary><see cref="T:System.Single"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Decimal})">
            <summary><see cref="T:System.Decimal"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Int32})">
            <summary><see cref="T:System.Int32"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Int64})">
            <summary><see cref="T:System.Int64"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Double}})">
            <summary>Nullable <see cref="T:System.Double"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための Nullable <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Single}})">
            <summary>Nullable <see cref="T:System.Single"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための Nullable <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>Nullable <see cref="T:System.Decimal"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための Nullable <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Int32}})">
            <summary>Nullable <see cref="T:System.Int32"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための Nullable <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max(System.IObservable{System.Nullable{System.Int64}})">
            <summary>Nullable <see cref="T:System.Int64"/> 値の監視可能なシーケンスの最大値を返します。</summary>
            <param name="source">最大値を判定するための Nullable <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最大値を持つ単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">最大を判定するためにソース シーケンス内の要素から派生したオブジェクトのタイプ。</typeparam>
            <param name="source">最小要素を決定する監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の最大要素に対応する値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>シーケンスの各要素で変換関数を呼び出し、指定した比較関数に従って最大値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">最大を判定するためにソース シーケンス内の要素から派生したオブジェクトのタイプ。</typeparam>
            <param name="source">最小要素を決定する監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <param name="comparer">要素の比較に使用される比較関数。</param>
            <returns>ソース シーケンス内の最大要素に対応する値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大 <see cref="T:System.Double"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Double"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大 <see cref="T:System.Single"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Single"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大 <see cref="T:System.Decimal"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Decimal"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大 <see cref="T:System.Int32"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Int32"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大 <see cref="T:System.Int64"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Int64"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大の Nullable <see cref="T:System.Double"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Nullable&lt;System.Double&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大の Nullable <see cref="T:System.Single"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Nullable&lt;System.Single&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大の Nullable <see cref="T:System.Decimal"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Nullable&lt;System.Decimal&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大の Nullable <see cref="T:System.Int32"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Nullable&lt;System.Int32&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Max``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最大の Nullable <see cref="T:System.Int64"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最大値を決定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスで最大値に対応する <see cref="T:System.Nullable&lt;System.Int64&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MaxBy``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>最大キー値を持つ監視可能なシーケンス内の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるキーのタイプ。</typeparam>
            <param name="source">最大要素を取得するための監視可能なシーケンス。</param>
            <param name="keySelector">キー選択関数。</param>
            <returns>最大キー値を持つ 0 個以上の要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MaxBy``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>指定された比較関数に従って、最大キー値を持つ監視可能なシーケンス内の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるキーのタイプ。</typeparam>
            <param name="source">最大要素を取得するための監視可能なシーケンス。</param>
            <param name="keySelector">キー選択関数。</param>
            <param name="comparer">キー値の比較に使用される比較関数。</param>
            <returns>最大キー値を持つ 0 個以上の要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0})">
            <summary>監視可能なシーケンス内の最小要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小要素を決定する監視可能なシーケンス。</param>
            <returns>ソース シーケンス内の最小要素がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Collections.Generic.IComparer{``0})">
            <summary>指定された比較関数に従って、監視可能なシーケンス内の最小要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小要素を決定する監視可能なシーケンス。</param>
            <param name="comparer">要素の比較に使用される比較関数。</param>
            <returns>ソース シーケンス内の最小要素がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Double})">
            <summary><see cref="T:System.Double"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Single})">
            <summary><see cref="T:System.Single"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Decimal})">
            <summary><see cref="T:System.Decimal"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Int32})">
            <summary><see cref="T:System.Int32"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Int64})">
            <summary><see cref="T:System.Int64"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Double}})">
            <summary>Nullable <see cref="T:System.Double"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する Nullable <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Single}})">
            <summary>Nullable <see cref="T:System.Single"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する Nullable <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>Nullable <see cref="T:System.Decimal"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する Nullable <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Int32}})">
            <summary>Nullable <see cref="T:System.Int32"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する Nullable <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min(System.IObservable{System.Nullable{System.Int64}})">
            <summary>Nullable <see cref="T:System.Int64"/> 値の監視可能なシーケンスの最小値を返します。</summary>
            <param name="source">最小値を判定する Nullable <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の最小値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">最小値を判定するためにソース シーケンス内の要素から派生したオブジェクトのタイプ。</typeparam>
            <param name="source">最小要素を決定する監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の最小要素に対応する値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>シーケンスの各要素で変換関数を呼び出し、指定した比較関数に従って最小値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">最小値を判定するためにソース シーケンス内の要素から派生したオブジェクトのタイプ。</typeparam>
            <param name="source">最小要素を決定する監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <param name="comparer">要素の比較に使用される比較関数。</param>
            <returns>ソース シーケンス内の最小要素に対応する値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 <see cref="T:System.Double"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Double"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 <see cref="T:System.Single"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Single"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 <see cref="T:System.Decimal"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Decimal"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 <see cref="T:System.Int32"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Int32"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 <see cref="T:System.Int64"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Int64"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 Nullable <see cref="T:System.Double"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Nullable&lt;System.Double&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 Nullable <see cref="T:System.Single"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Nullable&lt;System.Single&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 Nullable <see cref="T:System.Decimal"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Nullable&lt;System.Decimal&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 Nullable <see cref="T:System.Int32"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Nullable&lt;System.Int32&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Min``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>シーケンスの各要素で変換関数を呼び出し、最小 Nullable <see cref="T:System.Int64"/> 値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">最小値を判定する値のシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンスの最小値に対応する <see cref="T:System.Nullable&lt;System.Int64&gt;"/> タイプの値がある単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MinBy``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>最小キー値を持つ監視可能なシーケンス内の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるキーのタイプ。</typeparam>
            <param name="source">最小要素を取得するための監視可能なシーケンス。</param>
            <param name="keySelector">キー選択関数。</param>
            <returns>最小キー値を持つ 0 個以上の要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MinBy``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>指定された比較関数に従って、最小キー値を持つ監視可能なシーケンスの要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるキーのタイプ。</typeparam>
            <param name="source">最小要素を取得するための監視可能なシーケンス。</param>
            <param name="keySelector">キー選択関数。</param>
            <param name="comparer">キー値の比較に使用される比較関数。</param>
            <returns>最小キー値を持つ 0 個以上の要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>要素をペアで比較して、2 つのシーケンスが等しいかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">比較する最初の監視可能なシーケンス。</param>
            <param name="second">比較する 2 番目の監視可能なシーケンス。</param>
            <returns>両方のシーケンスが同じ長さであり、対応する要素がタイプの既定の等値比較関数に従って等しいかどうかを示す単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.IObservable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>指定された等値比較関数を使用して要素をペアで比較することにより、2 つのシーケンスが等しいかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">比較する最初の監視可能なシーケンス。</param>
            <param name="second">比較する 2 番目の監視可能なシーケンス。</param>
            <param name="comparer">両方のシーケンスの要素を比較するために使用される比較関数。</param>
            <returns>両方のシーケンスが同じ長さであり、対応する要素が指定された等値比較関数に従って等しいかどうかを示す単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>要素をペアで比較して、監視可能および列挙可能なシーケンスが等しいかどうかを決定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">比較する最初の監視可能なシーケンス。</param>
            <param name="second">比較する 2 番目の監視可能なシーケンス。</param>
            <returns>両方のシーケンスが同じ長さであり、対応する要素がタイプの既定の等値比較関数に従って等しいかどうかを示す単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SequenceEqual``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>指定された等値比較関数を使用して要素をペアで比較することにより、監視可能および列挙可能なシーケンスが等しいかどうかを判定します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">比較する最初の監視可能なシーケンス。</param>
            <param name="second">比較する 2 番目の監視可能なシーケンス。</param>
            <param name="comparer">両方のシーケンスの要素を比較するために使用される比較関数。</param>
            <returns>両方のシーケンスが同じ長さであり、対応する要素が指定された等値比較関数に従って等しいかどうかを示す単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの唯一の要素を返し、監視可能なシーケンスに正確に 1 つの要素がない場合は例外を報告します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の単一要素を含むシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスには複数の要素が含まれています。-または- ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの唯一の要素を返し、監視可能なシーケンスに正確に 1 つの要素がない場合は例外を報告します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンス内の単一要素を含むシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) 述語の条件を満たす要素はありません。-または- 複数の要素が述語の条件を満たしています。-または- ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの唯一の要素、または監視可能なシーケンスが空の場合は既定値を返します。このメソッドは、監視可能なシーケンスに複数の要素がある場合は例外を報告します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の単一要素を含むシーケンス、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) ソース シーケンスには複数の要素が含まれています。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語に一致する監視可能なシーケンスの唯一の要素を返し、そのような要素が存在しない場合は既定値を返します。このメソッドは、監視可能なシーケンスに複数の要素がある場合は例外を報告します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンス内の単一要素を含むシーケンス、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">(非同期) シーケンスには、述語の条件を満たす複数の要素が含まれています。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Double})">
            <summary>一連の <see cref="T:System.Double"/> 値の合計を計算します。</summary>
            <param name="source">合計を計算するための <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Single})">
            <summary>一連の <see cref="T:System.Single"/> 値の合計を計算します。</summary>
            <param name="source">合計を計算するための <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Decimal})">
            <summary>一連の <see cref="T:System.Decimal"/> 値の合計を計算します。</summary>
            <param name="source">合計を計算するための <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Int32})">
            <summary>一連の <see cref="T:System.Int32"/> 値の合計を計算します。</summary>
            <param name="source">合計を計算するための <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int32.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Int64})">
            <summary>一連の <see cref="T:System.Int64"/> 値の合計を計算します。</summary>
            <param name="source">合計を計算するための <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Double}})">
            <summary>Nullable <see cref="T:System.Double"/> 値のシーケンスの合計を計算します。</summary>
            <param name="source">合計を計算するための Nullable <see cref="T:System.Double"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Single}})">
            <summary>Nullable <see cref="T:System.Single"/> 値のシーケンスの合計を計算します。</summary>
            <param name="source">合計を計算するための Nullable <see cref="T:System.Single"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Decimal}})">
            <summary>Nullable <see cref="T:System.Decimal"/> 値のシーケンスの合計を計算します。</summary>
            <param name="source">合計を計算するための Nullable <see cref="T:System.Decimal"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Int32}})">
            <summary>Nullable <see cref="T:System.Int32"/> 値のシーケンスの合計を計算します。</summary>
            <param name="source">合計を計算するための Nullable <see cref="T:System.Int32"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int32.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum(System.IObservable{System.Nullable{System.Int64}})">
            <summary>Nullable <see cref="T:System.Int64"/> 値のシーケンスの合計を計算します。</summary>
            <param name="source">合計を計算するための Nullable <see cref="T:System.Int64"/> 値のシーケンス。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きい。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Double})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Double"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Single})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Single"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Decimal})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Decimal"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Int32})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Int32"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int32.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Int64})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される <see cref="T:System.Int64"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Double"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Single"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Decimal"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Decimal.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Int32"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int32.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sum``1(System.IObservable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>入力シーケンスの各要素で変換関数を呼び出すことによって取得される Nullable <see cref="T:System.Int64"/> 値のシーケンスの合計を計算します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">合計の計算に使用される一連の値。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>ソース シーケンス内の値の合計がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.OverflowException">(非同期) ソース シーケンス内の要素の予測値の合計が <see cref="M:System.Int64.MaxValue"/> よりも大きくなっています。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToArray``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスから配列を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素の配列を取得するためのソースの監視可能なシーケンス。</param>
            <returns>ソース シーケンスのあらゆる要素を含む配列がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>指定されたキー選択関数に従って、監視可能なシーケンスから辞書を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される辞書キーのタイプ。</typeparam>
            <param name="source">辞書を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする辞書がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数と比較関数に従って、監視可能なシーケンスから辞書を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される辞書キーのタイプ。</typeparam>
            <param name="source">辞書を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <param name="comparer">キーを比較するための等値比較関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする辞書がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>指定されたキー選択関数と要素選択関数に従って、監視可能なシーケンスから辞書を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される辞書キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算される辞書値のタイプ。</typeparam>
            <param name="source">辞書を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <param name="elementSelector">各要素から結果要素値を生成する変換関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする辞書がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToDictionary``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数、比較関数、および要素選択関数に従って、監視可能なシーケンスから辞書を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される辞書キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算される辞書値のタイプ。</typeparam>
            <param name="source">辞書を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <param name="elementSelector">各要素から結果要素値を生成する変換関数。</param>
            <param name="comparer">キーを比較するための等値比較関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする辞書がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> もしくは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToList``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスからリストを作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素のリストを取得するためのソースの監視可能なシーケンス。</param>
            <returns>ソース シーケンスのあらゆる要素を含むリストがある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>指定されたキー選択関数に従って、監視可能なシーケンスから検索を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される参照キーのタイプ。</typeparam>
            <param name="source">検索を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする検索がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数と比較関数に従って、監視可能なシーケンスから検索を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される参照キーのタイプ。</typeparam>
            <param name="source">検索を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <param name="comparer">キーを比較するための等値比較関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする検索がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>指定されたキー選択関数と要素選択関数に従って、監視可能なシーケンスから検索を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される参照キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算される検索値のタイプ。</typeparam>
            <param name="source">検索を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <param name="elementSelector">各要素から結果要素値を生成する変換関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする検索がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToLookup``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数、比較関数、および要素選択関数に従って、監視可能なシーケンスから検索を作成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される参照キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算される検索値のタイプ。</typeparam>
            <param name="source">検索を作成するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素からキーを抽出する関数。</param>
            <param name="elementSelector">各要素から結果要素値を生成する変換関数。</param>
            <param name="comparer">キーを比較するための等値比較関数。</param>
            <returns>対応するソース シーケンスの要素に一意のキー値をマッピングする検索がある単一要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> もしくは <paramref name="comparer"/> は null です。</exception>
            <remarks>この演算子の戻り値のタイプは、非同期動作を保持するために IEnumerable の対応する演算子とは異なります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GetAwaiter``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最後の値を返すアウェイターを取得するか、シーケンスが空の場合は例外をスローします。この操作は、観測可能なシーケンスにサブスクライブし、これをホットにします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">待機するソース シーケンス。</param>
            <returns>待機できるオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GetAwaiter``1(System.Reactive.Subjects.IConnectableObservable{``0})">
            <summary>監視可能なシーケンスの最後の値を返すアウェイターを取得するか、シーケンスが空の場合は例外をスローします。この操作は、監視可能なシーケンスにサブスクライブして接続し、これをホットにします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">待機するソース シーケンス。</param>
            <returns>待機できるオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.RunAsync``1(System.IObservable{``0},System.Threading.CancellationToken)">
            <summary>監視可能なシーケンスの最後の値を返すアウェイターを取得するか、シーケンスが空の場合は例外をスローします。この操作は、観測可能なシーケンスにサブスクライブし、これをホットにします。指定された CancellationToken を使用するとサブスクリプションをキャンセルできます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">待機するソース シーケンス。</param>
            <param name="cancellationToken">キャンセル トークン。</param>
            <returns>待機できるオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.RunAsync``1(System.Reactive.Subjects.IConnectableObservable{``0},System.Threading.CancellationToken)">
            <summary>監視可能なシーケンスの最後の値を返すアウェイターを取得するか、シーケンスが空の場合は例外をスローします。この操作は、監視可能なシーケンスにサブスクライブして接続し、これをホットにします。指定された CancellationToken を使用するとサブスクリプションと接続をキャンセルできます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">待機するソース シーケンス。</param>
            <param name="cancellationToken">キャンセル トークン。</param>
            <returns>待機できるオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Multicast``2(System.IObservable{``0},System.Reactive.Subjects.ISubject{``0,``1})">
            <summary>指定されたサブジェクトを介してソース シーケンス通知を接続可能な結果的監視対象にマルチキャストします。接続可能な監視可能の接続後、サブジェクトはひとつのソースにサブスクライブされ、メッセージは接続可能な監視可能に登録されたオブザーバーに転送されます。固定サブジェクト タイプの特殊化については、「Publish、PublishLast、Replay」を参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">要素が指定されたサブジェクトにプッシュされるソース シーケンス。</param>
            <param name="subject">ソース要素のプッシュ先のサブジェクト。</param>
            <returns>接続後にソース シーケンスが指定されたサブジェクトに結果をプッシュする接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="subject"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Multicast``3(System.IObservable{``0},System.Func{System.Reactive.Subjects.ISubject{``0,``1}},System.Func{System.IObservable{``1},System.IObservable{``2}})">
            <summary>インスタンス化されたサブジェクトを介して、選択関数内のシーケンスのあらゆる用途にソース シーケンス通知をマルチキャストします。結果のシーケンスに対する各サブスクリプションでは、個別のマルチキャスト呼び出しが発生し、選択関数の呼び出しに起因するシーケンスが公開されます。固定サブジェクト タイプの特殊化については、「Publish、PublishLast、Replay」を参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TIntermediate">中間サブジェクトによって生成される要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">指定された選択関数でマルチキャストされるソース シーケンス。</param>
            <param name="subjectSelector">ソース シーケンスの要素が選択関数にマルチキャストされる中間サブジェクトを作成するためのファクトリ関数。</param>
            <param name="selector">作成されたサブジェクトによって適用されるポリシーの対象となるマルチキャスト済みソース シーケンスを使用できる選択関数。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="subjectSelector"/> あるいは <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``1(System.IObservable{``0})">
            <summary>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスを返します。この演算子は、通常の <see cref="T:System.Reactive.Subjects.Subject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>サブスクライバーは、サブスクリプションの時点からソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.Subject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}})">
            <summary>単一のサブスクリプションを基になるシーケンスに共有する接続可能な監視可能シーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、通常の <see cref="T:System.Reactive.Subjects.Subject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、サブスクリプションの時点からソースのすべての通知を受け取ります。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <seealso cref="T:System.Reactive.Subjects.Subject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``1(System.IObservable{``0},``0)">
            <summary>基になるシーケンスに単一のサブスクリプションを共有し、initialValue で始まる接続可能な監視可能シーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.BehaviorSubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="initialValue">サブスクリプション後にオブザーバーが受け取る初期値。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>サブスクライバーは初期値を即座に受け取り、その後、サブスクリプションの時点からソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Publish``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},``0)">
            <summary>単一のサブスクリプションを基になるシーケンスに共有し、initialValue で始まる接続可能な監視可能シーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.BehaviorSubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは初期値を即座に受け取り、その後、サブスクリプションの時点からソースのすべての通知を受け取ります。</param>
            <param name="initialValue">サブスクリプション後にオブザーバーが受け取る初期値。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <seealso cref="T:System.Reactive.Subjects.BehaviorSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.PublishLast``1(System.IObservable{``0})">
            <summary>最後の通知のみが含まれている基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.AsyncSubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>サブスクライバーは、ソースの最後の通知のみを受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.AsyncSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.PublishLast``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}})">
            <summary>最後の通知のみが含まれている基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.AsyncSubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースのサブスクライバーは、ソースの最後の通知のみを受け取ります。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <seealso cref="T:System.Reactive.Subjects.AsyncSubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.RefCount``1(System.Reactive.Subjects.IConnectableObservable{``0})">
            <summary>監視可能なシーケンスに少なくとも 1 つのサブスクリプションがある限り、ソースに接続されたままの監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">接続可能な監視可能シーケンス。</param>
            <returns>監視可能なシーケンスに少なくとも 1 つのサブスクリプションがある限り、ソースに接続されたままの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0})">
            <summary>すべての通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>サブスクライバーは、ソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>すべての通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="scheduler">接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>サブスクライバーは、ソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}})">
            <summary>すべての通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、ソースのすべての通知を受け取ります。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Reactive.Concurrency.IScheduler)">
            <summary>すべての通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、ソースのすべての通知を受け取ります。</param>
            <param name="scheduler">選択関数内で接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.TimeSpan)">
            <summary>再生バッファーの最大時間長の影響を受ける通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>サブスクライバーは、指定された再生バッファーのトリミング ポリシーの対象となるソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.TimeSpan)">
            <summary>再生バッファーの最大時間長の影響を受ける基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、指定された再生バッファーのトリミングポリシーの対象となるソースのすべての通知を受け取ります。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>再生バッファーの最大時間長の影響を受ける通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <param name="scheduler">接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>サブスクライバーは、指定された再生バッファーのトリミング ポリシーの対象となるソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>再生バッファーの最大時間長の影響を受ける基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、指定された再生バッファーのトリミングポリシーの対象となるソースのすべての通知を受け取ります。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <param name="scheduler">選択関数内で接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>bufferSize 通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能・監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="scheduler">接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <remarks>サブスクライバーは、指定された再生バッファーのトリミング ポリシーの対象となるソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>再生バッファーの最大要素数の対象となる基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、指定された再生バッファーのトリミングポリシーの対象となるソースのすべての通知を受け取ります。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="scheduler">選択関数内で接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32)">
            <summary>再生バッファーの最大要素数の対象となる基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <remarks>サブスクライバーは、指定された再生バッファーのトリミング ポリシーの対象となるソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32)">
            <summary>再生バッファーの最大要素数の対象となる基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、指定された再生バッファーのトリミングポリシーの対象となるソースのすべての通知を受け取ります。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32,System.TimeSpan)">
            <summary>再生バッファーの最大時間長と要素数の影響を受ける通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能・観測可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>サブスクライバーは、指定された再生バッファーのトリミング ポリシーの対象となるソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32,System.TimeSpan)">
            <summary>再生の最大時間長と要素数の影響を受ける基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、指定された再生バッファーのトリミングポリシーの対象となるソースのすべての通知を受け取ります。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``1(System.IObservable{``0},System.Int32,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>再生バッファーの最大時間長と要素数の影響を受ける通知を再生する基になるシーケンスに単一のサブスクリプションを共有する接続可能・観測可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <param name="scheduler">接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>基になるシーケンスに単一のサブスクリプションを共有する接続可能な監視可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>サブスクライバーは、指定された再生バッファーのトリミング ポリシーの対象となるソースのすべての通知を受け取ります。</remarks>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Replay``2(System.IObservable{``0},System.Func{System.IObservable{``0},System.IObservable{``1}},System.Int32,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>再生の最大時間長と要素数の影響を受ける基になるシーケンス再生通知に単一のサブスクリプションを共有する接続可能・監視可能なシーケンスでセレクターを呼び出した結果である、監視可能なシーケンスを返します。この演算子は、<see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> を使用したマルチキャストの特殊化です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">結果シーケンスの要素のタイプ。</typeparam>
            <param name="source">単一の共有サブスクリプションを介して要素がマルチキャストされるソース シーケンス。</param>
            <param name="selector">ソース シーケンスへの複数のサブスクリプションを発生させることなく、マルチキャストされたソース シーケンスを必要な回数まで使用できる選択関数。特定のソースへのサブスクライバーは、指定された再生バッファーのトリミングポリシーの対象となるソースのすべての通知を受け取ります。</param>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <param name="scheduler">選択関数内で接続されたオブザーバーが呼び出される Scheduler。</param>
            <returns>選択関数内のソース シーケンスをマルチキャストすることによって生成されるシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <seealso cref="T:System.Reactive.Subjects.ReplaySubject`1"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Chunkify``1(System.IObservable{``0})">
            <summary>ソース シーケンスの連続した (空の可能性がある) チャンクの列挙可能なシーケンスを生成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>各反復時に連続する (空の可能性がある) チャンクを返す列挙可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Collect``2(System.IObservable{``0},System.Func{``1},System.Func{``1,``0,``1})">
            <summary>連続する反復の間にソース シーケンスから収集/集計された要素を返す列挙可能シーケンスを生成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">収集中にマージ操作によって生成される要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="newCollector">新しいコレクター オブジェクトを作成するファクトリ。</param>
            <param name="merge">シーケンス要素を現在のコレクターとマージします。</param>
            <returns>各反復時にソース シーケンスから収集/集約された要素を返す列挙可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="newCollector"/> あるいは <paramref name="merge"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Collect``2(System.IObservable{``0},System.Func{``1},System.Func{``1,``0,``1},System.Func{``1,``1})">
            <summary>連続する反復の間にソース シーケンスから収集/集計された要素を返す列挙可能シーケンスを生成します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">収集中にマージ操作によって生成される要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="getInitialCollector">初期コレクター オブジェクトを作成するファクトリ。</param>
            <param name="merge">シーケンス要素を現在のコレクターとマージします。</param>
            <param name="getNewCollector">現在のコレクターを新しいコレクターに置き換えるファクトリ。</param>
            <returns>各反復時にソース シーケンスから収集/集約された要素を返す列挙可能シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="getInitialCollector"/> あるいは <paramref name="merge"/> もしくは <paramref name="getNewCollector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.First``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最初の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの最初の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.First``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最初の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンスの最初の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">述語の条件を満たす要素はありません。-または- ソース シーケンスが空です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefault``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最初の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの最初の要素、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.FirstOrDefault``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最初の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンスの最初の要素、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.FirstOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEach``1(System.IObservable{``0},System.Action{``0})">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、シーケンスが終了するまでブロックします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
            <remarks>ブロッキングの性質上、この演算子は主にテストで使用されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ForEach``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>監視可能シーケンス内の各要素に対してアクションを呼び出し、要素のインデックスを組み込み、シーケンスが終了するまでブロックします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
            <remarks>ブロッキングの性質上、この演算子は主にテストで使用されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GetEnumerator``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスのすべての値を列挙する列挙子を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">列挙子を取得するための監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の要素を列挙するために使用できる列挙子。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Last``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最後の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの最後の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Last``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最後の要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンスの最後の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">述語の条件を満たす要素はありません。-または- ソース シーケンスが空です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefault``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの最後の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの最後の要素、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.LastOrDefault``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの最後の要素、またはそのような要素が存在しない場合は既定値を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンスの最後の要素、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.LastOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Latest``1(System.IObservable{``0})">
            <summary>リストがソースの監視可能なシーケンスで最新の監視要素を返す列挙可能なシーケンスを返します。結果のシーケンス上の列挙子は、同じ要素を繰り返し生成することはなく、次の要素が使用可能になるまでブロックされます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>各反復時に最後にサンプリングされた要素を返し、その後、監視可能なソース シーケンス内の次の要素が使用可能になるまでブロックする列挙可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.MostRecent``1(System.IObservable{``0},``0)">
            <summary>まだ要素がサンプリングされていない場合は指定された初期値を使い、リストがソースの監視可能なシーケンス内で最も直近に観測された要素を返す列挙可能なシーケンスを返します。結果のシーケンス上の列挙子は同じ要素をブロックせず、繰り返し生成できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="initialValue">要素がまだサンプリングされていない場合、列挙可能なシーケンスによって生成される初期値。</param>
            <returns>各反復時に最後にサンプリングされた要素を返す列挙可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Next``1(System.IObservable{``0})">
            <summary>ソースの監視可能なシーケンス内の次の要素が使用可能になるまで列挙がブロックする列挙可能なシーケンスを返します。結果のシーケンスの列挙子は、次の要素が使用可能になるまでブロックされます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なソース シーケンス内の次の要素が使用可能になるまで、各反復でブロックする列挙可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Single``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの唯一の要素を返し、監視可能なシーケンスに要素が正確に 1 つない場合は例外をスローします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の単一の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">ソース シーケンスには複数の要素が含まれています。-または- ソース シーケンスが空です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Single``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの唯一の要素を返し、監視可能なシーケンスで述語に一致する要素が正確に 1 つでない場合に例外をスローします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンス内の単一の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">述語の条件を満たす要素はありません。-または- 複数の要素が述語の条件を満たしています。-または- ソース シーケンスが空です。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefault``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの唯一の要素、または監視可能なシーケンスが空の場合は既定値を返します。このメソッドは、監視可能なシーケンスに複数の要素がある場合に例外をスローします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンス内の単一の要素、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">ソース シーケンスには複数の要素が含まれています。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SingleOrDefault``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語の条件を満たす監視可能なシーケンスの唯一の要素を返し、そのような要素が存在しない場合は既定値を返します。このメソッドは、監視可能なシーケンスの述語に一致する要素が複数ある場合に例外をスローします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <param name="predicate">ソース シーケンス内の要素を評価する述語関数。</param>
            <returns>述語の条件を満たす監視可能なシーケンス内の単一の要素、またはそのような要素が存在しない場合は既定値。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">シーケンスには、述語の条件を満たす複数の要素が含まれています。</exception>
            <seealso cref="M:System.Reactive.Linq.Observable.SingleOrDefaultAsync``1(System.IObservable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Wait``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスが完了するのを待ち、シーケンスの最後の要素を返します。シーケンスが OnError 通知で終了した場合は、例外がスローされます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソースの監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの最後の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定した Scheduler でオブザーバー コールバックを実行するためにソース シーケンスをラップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="scheduler">オブザーバーに通知する Scheduler。</param>
            <returns>指定した Scheduler で監視が行われるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>これは、Scheduler のオブザーバー コールバックのみを呼び出します。サブスクリプションやサブスクリプション解除アクションに、Scheduler で実行する必要がある副作用がある場合は、 <see cref="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)"/>を使用します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
            <summary>指定した同期コンテキストでオブザーバー コールバックを実行するためにソース シーケンスをラップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="context">オブザーバーに通知する同期コンテキスト。</param>
            <returns>指定された同期コンテキストで監視が行われるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="context"/> は null です。</exception>
            <remarks>これは、同期コンテキストでオブザーバー コールバックのみを呼び出します。サブスクリプションやサブスクリプション解除アクションに、同期コンテキストで実行する必要がある副作用がある場合は、 <see cref="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)"/>を使用します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定した Scheduler でサブスクリプションとサブスクリプション解除ロジックを実行するためにソース シーケンスをラップします。この操作は一般的には使用されません。SubscribeOn と ObserveOn の違いの詳細については、解説セクションを参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="scheduler">サブスクリプションおよびサブスクリプション解除アクションを実行する Scheduler。</param>
            <returns>指定した Scheduler でサブスクリプションとサブスクリプション解除が発生するソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>これは、指定された Scheduler に対するサブスクリプションとサブスクリプション解除の副作用のみを実行します。Scheduler でオブザーバー コールバックを呼び出すには、 <see cref="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)"/>を使用します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SubscribeOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)">
            <summary>指定された同期コンテキストでサブスクリプションとサブスクリプション解除ロジックを実行するためにソース シーケンスをラップします。この操作は一般的には使用されません。SubscribeOn と ObserveOn の違いの詳細については、解説セクションを参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="context">サブスクリプションとサブスクリプション解除のアクションを実行する同期コンテキスト。</param>
            <returns>指定された同期コンテキストでサブスクリプションとサブスクリプション解除が発生するソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="context"/> は null です。</exception>
            <remarks>これは、指定された同期コンテキストでサブスクリプションとサブスクリプション解除の副作用のみを実行します。同期コンテキストでオブザーバー コールバックを呼び出すには、 <see cref="M:System.Reactive.Linq.Observable.ObserveOn``1(System.IObservable{``0},System.Threading.SynchronizationContext)"/>を使用します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Synchronize``1(System.IObservable{``0})">
            <summary>オブザーバー通知を同時に配信できないように監視可能なシーケンスを同期します。このオーバーロードは、個々のオブザーバーに同時コールバックを示す監視可能なシーケンスを「修正」する場合に便利です。これはクエリ プロセッサでは無効な動作です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <returns>オブザーバーへの発信呼び出しが同期されるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>オブザーバー文法によると、シーケンスが特定のオブザーバーに同時コールバックを表示する場合は無効な動作です。この演算子を使用して、この規則に準拠しないソースを「修正」できます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Synchronize``1(System.IObservable{``0},System.Object)">
            <summary>指定されたゲート オブジェクトを使用して、オブザーバー通知を同時に配信できないような監視可能シーケンスを同期します。このオーバーロードは、共通ゲート オブジェクトで同期することにより、異なるソースからの同時コールバックを防ぐために n-ary クエリ演算子を作成する場合に便利です。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="gate">各オブザーバー呼び出しを同期するゲート オブジェクト。</param>
            <returns>オブザーバーへの発信呼び出しが特定のゲート オブジェクトで同期されるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="gate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Subscribe``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0})">
            <summary>オブザーバーを列挙可能なシーケンスにサブスクライブします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サブスクライブする列挙可能なシーケンス。</param>
            <param name="observer">列挙可能なシーケンスから通知を受け取るオブザーバー。</param>
            <returns>列挙可能からのオブザーバーのサブスクライブ解除に使用できる破棄可能なオブジェクト</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="observer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Subscribe``1(System.Collections.Generic.IEnumerable{``0},System.IObserver{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用して列挙ループを実行し、オブザーバーを列挙可能なシーケンスにサブスクライブします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サブスクライブする列挙可能なシーケンス。</param>
            <param name="observer">列挙可能なシーケンスから通知を受け取るオブザーバー。</param>
            <param name="scheduler">列挙を実行する Scheduler。</param>
            <returns>列挙可能からのオブザーバーのサブスクライブ解除に使用できる破棄可能なオブジェクト</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="observer"/> あるいは <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEnumerable``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスを列挙可能なシーケンスに変換します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">列挙可能なシーケンスに変換する監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの要素を含む列挙可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEvent(System.IObservable{System.Reactive.Unit})">
            <summary>Action ベースの .NET イベントを持つオブジェクトとして、監視可能なシーケンスを公開します。</summary>
            <param name="source">監視可能なソース シーケンス。</param>
            <returns>イベント ソース オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEvent``1(System.IObservable{``0})">
            <summary>Action&lt;TSource&gt; ベースの .NET イベントを持つオブジェクトとして、監視可能なシーケンスを公開します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">監視可能なソース シーケンス。</param>
            <returns>イベント ソース オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToEventPattern``1(System.IObservable{System.Reactive.EventPattern{``0}})">
            <summary>標準の .NET イベント パターンに準拠して、.NET イベントを持つオブジェクトとして監視可能なシーケンスを公開します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
            <param name="source">監視可能なソース シーケンス。</param>
            <returns>イベント ソース オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>列挙可能なシーケンスを監視可能なシーケンスに変換します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">監視可能なシーケンスに変換する列挙可能なシーケンス。</param>
            <returns>指定された列挙可能なシーケンスから要素が引き出される監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定した Scheduler を使用して列挙ループを実行し、列挙可能なシーケンスを監視可能なシーケンスに変換します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">監視可能なシーケンスに変換する列挙可能なシーケンス。</param>
            <param name="scheduler">入力シーケンスの列挙を実行する Scheduler。</param>
            <returns>指定された列挙可能なシーケンスから要素が引き出される監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.IDisposable})">
            <summary>指定された Subscribe メソッドの実装から監視可能なシーケンスを作成します。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribe">結果として得られる監視可能なシーケンスの Subscribe メソッドの実装。</param>
            <returns>Subscribe メソッド向けに指定された実装のある監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribe"/> は null です。</exception>
            <remarks>この演算子の使用は、IObservable&lt;T&gt; インターフェイスの手動実装よりも優先されます。匿名実装ではなく IObservable&lt;T&gt; を実装するタイプが必要な場合は、 <see cref="T:System.Reactive.ObservableBase`1"/> 抽象基本クラスの使用を検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Action})">
            <summary>指定された Subscribe メソッドの実装から監視可能なシーケンスを作成します。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribe">結果として得られる監視可能なシーケンスの Subscribe メソッドを実装し、IDisposable でラップされる Action デリゲートを返します。</param>
            <returns>Subscribe メソッド向けに指定された実装のある監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribe"/> は null です。</exception>
            <remarks>この演算子の使用は、IObservable&lt;T&gt; インターフェイスの手動実装よりも優先されます。匿名実装ではなく IObservable&lt;T&gt; を実装するタイプが必要な場合は、 <see cref="T:System.Reactive.ObservableBase`1"/> 抽象基本クラスの使用を検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>指定された取り消し可能な非同期 Subscribe メソッドから監視可能なシーケンスを作成します。非同期 Subscribe メソッドに渡される CancellationToken は、返される破棄可能なサブスクリプションに関連付けられ、ベスト エフォートの取り消しが可能です。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribeAsync">要素の生成に使用される非同期メソッド。</param>
            <returns>非同期メソッドによって生成される要素を明らかにする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、非同期サブスクライブ関数に供給された CancellationToken が通知されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.Tasks.Task})">
            <summary>指定された非同期 Subscribe メソッドから監視可能なシーケンスを作成します。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribeAsync">要素の生成に使用される非同期メソッド。</param>
            <returns>非同期メソッドによって生成される要素を明らかにする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>指定された取り消し可能な非同期 Subscribe メソッドから監視可能なシーケンスを作成します。非同期 Subscribe メソッドに渡される CancellationToken は、返される破棄可能なサブスクリプションに関連付けられ、ベスト エフォートの取り消しが可能です。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribeAsync">結果のシーケンスの Subscribe メソッドを実装するために使用される非同期メソッド。</param>
            <returns>Subscribe メソッド向けに指定された実装のある監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、非同期サブスクライブ関数に供給された CancellationToken が通知されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.Tasks.Task{System.IDisposable}})">
            <summary>指定された非同期 Subscribe メソッドから監視可能なシーケンスを作成します。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribeAsync">結果のシーケンスの Subscribe メソッドを実装するために使用される非同期メソッド。</param>
            <returns>Subscribe メソッド向けに指定された実装のある監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Action}})">
            <summary>指定された取り消し可能な非同期 Subscribe メソッドから監視可能なシーケンスを作成します。非同期 Subscribe メソッドに渡される CancellationToken は、返される破棄可能なサブスクリプションに関連付けられ、ベスト エフォートの取り消しが可能です。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribeAsync">結果のシーケンスの Subscribe メソッドを実装するために使用される非同期メソッドで、IDisposable でラップされる Action デリゲートを返します。</param>
            <returns>Subscribe メソッド向けに指定された実装のある監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、非同期サブスクライブ関数に供給された CancellationToken が通知されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Create``1(System.Func{System.IObserver{``0},System.Threading.Tasks.Task{System.Action}})">
            <summary>指定された非同期 Subscribe メソッドから監視可能なシーケンスを作成します。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="subscribeAsync">結果のシーケンスの Subscribe メソッドを実装するために使用される非同期メソッドで、IDisposable でラップされる Action デリゲートを返します。</param>
            <returns>Subscribe メソッド向けに指定された実装のある監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subscribeAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Defer``1(System.Func{System.IObservable{``0}})">
            <summary>新しいオブザーバーがサブスクライブするたびに、指定されたファクトリ関数を呼び出す監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">ファクトリ関数によって返されるシーケンス、および結果のシーケンスの要素のタイプ。</typeparam>
            <param name="observableFactory">結果のシーケンスにサブスクライブする各オブザーバーに対して呼び出す監視可能なファクトリ関数。</param>
            <returns>オブザーバーが特定の監視可能なファクトリ関数の呼び出しをトリガーする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observableFactory"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Defer``1(System.Func{System.Threading.Tasks.Task{System.IObservable{``0}}})">
            <summary>新しいオブザーバーがサブスクライブするたびに、指定された非同期ファクトリ関数を開始する監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">ファクトリ関数によって返されるシーケンス、および結果のシーケンスの要素のタイプ。</typeparam>
            <param name="observableFactoryAsync">結果のシーケンスにサブスクライブする各オブザーバーに対して開始する非同期ファクトリ関数。</param>
            <returns>オブザーバーが特定の非同期監視可能ファクトリ関数を開始するようトリガーする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observableFactoryAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DeferAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IObservable{``0}}})">
            <summary>新しいオブザーバーがサブスクライブするたびに、指定された取り消し可能な非同期ファクトリ関数を開始する監視可能なシーケンスを返します。非同期ファクトリ関数に渡される CancellationToken は、返される破棄可能なサブスクリプションに関連付けられているため、ベスト エフォートの取り消しが可能になります。</summary>
            <typeparam name="TResult">ファクトリ関数によって返されるシーケンス、および結果のシーケンスの要素のタイプ。</typeparam>
            <param name="observableFactoryAsync">結果のシーケンスにサブスクライブする各オブザーバーに対して開始する非同期ファクトリ関数。</param>
            <returns>オブザーバーが特定の非同期監視可能ファクトリ関数を開始するようトリガーする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observableFactoryAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、監視可能な非同期ファクトリ関数に供給された CancellationToken が通知されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1">
            <summary>空の監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプパラメーターに使用されるタイプ。</typeparam>
            <returns>要素のない監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1(``0)">
            <summary>空の監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプパラメーターに使用されるタイプ。</typeparam>
            <param name="witness"><typeparamref name="TResult"/> タイプを推測するためにのみ使用されるオブジェクト。このパラメーターは通常、匿名でタイプ指定された要素のシーケンスを作成するときに使用されます。</param>
            <returns>要素のない監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1(System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用して、単一の OnCompleted メッセージを送信する空の監視可能シーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプパラメーターに使用されるタイプ。</typeparam>
            <param name="scheduler">終了コールを送信する Scheduler。</param>
            <returns>要素のない監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Empty``1(System.Reactive.Concurrency.IScheduler,``0)">
            <summary>指定された Scheduler を使用して、単一の OnCompleted メッセージを送信する空の監視可能シーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプパラメーターに使用されるタイプ。</typeparam>
            <param name="scheduler">終了コールを送信する Scheduler。</param>
            <param name="witness"><typeparamref name="TResult"/> タイプを推測するためにのみ使用されるオブジェクト。このパラメーターは通常、匿名でタイプ指定された要素のシーケンスを作成するときに使用されます。</param>
            <returns>要素のない監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1})">
            <summary>シーケンスの要素を生成する状態駆動タイプループを実行して、監視可能なシーケンスを生成します。</summary>
            <typeparam name="TState">ジェネレーター ループで使用される状態のタイプ。</typeparam>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="initialState">初期状態。</param>
            <param name="condition">生成を終了する条件 (false を返す場合)。</param>
            <param name="iterate">反復ステップ関数。</param>
            <param name="resultSelector">シーケンスで生成された結果の選択関数。</param>
            <returns>生成されたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="iterate"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>シーケンスの要素を生成する状態駆動タイプループを実行して監視可能なシーケンスを生成し、指定された Scheduler を使用してオブザーバー メッセージを送信します。</summary>
            <typeparam name="TState">ジェネレーター ループで使用される状態のタイプ。</typeparam>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="initialState">初期状態。</param>
            <param name="condition">生成を終了する条件 (false を返す場合)。</param>
            <param name="iterate">反復ステップ関数。</param>
            <param name="resultSelector">シーケンスで生成された結果の選択関数。</param>
            <param name="scheduler">ジェネレーター ループを実行する Scheduler。</param>
            <returns>生成されたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="iterate"/> あるいは <paramref name="resultSelector"/> もしくは <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Never``1">
            <summary>無限の期間 (事後対応結合を使用する場合など) を示すために使用できる、終端でない監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプパラメーターに使用されるタイプ。</typeparam>
            <returns>オブザーバーが呼び出されない監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Never``1(``0)">
            <summary>無限の期間 (事後対応結合を使用する場合など) を示すために使用できる、終端でない監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプパラメーターに使用されるタイプ。</typeparam>
            <param name="witness"><typeparamref name="TResult"/> タイプを推測するためにのみ使用されるオブジェクト。このパラメーターは通常、匿名でタイプ指定された要素のシーケンスを作成するときに使用されます。</param>
            <returns>オブザーバーが呼び出されない監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Range(System.Int32,System.Int32)">
            <summary>指定された範囲内で整数の監視可能なシーケンスを生成します。</summary>
            <param name="start">シーケンスの最初の整数の値。</param>
            <param name="count">生成する連続した整数の数。</param>
            <returns>連続した整数の範囲を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。-または- <paramref name="start"/> + -<paramref name="count"/> - 1 は <see cref="M:System.Int32.MaxValue"/> よりも大きくなります。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Range(System.Int32,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された範囲内で整数の監視可能なシーケンスを生成し、指定された Scheduler を使用してオブザーバー メッセージを送信します。</summary>
            <param name="start">シーケンスの最初の整数の値。</param>
            <param name="count">生成する連続した整数の数。</param>
            <param name="scheduler">ジェネレーター ループを実行する Scheduler。</param>
            <returns>連続した整数の範囲を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。-または- <paramref name="start"/> + -<paramref name="count"/> - 1 は <see cref="M:System.Int32.MaxValue"/> よりも大きくなります。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0)">
            <summary>特定の要素を無限に繰り返す監視可能なシーケンスを生成します。</summary>
            <typeparam name="TResult">生成されたシーケンスで繰り返される要素のタイプ。</typeparam>
            <param name="value">繰り返す要素。</param>
            <returns>特定の要素を無限に繰り返す監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Reactive.Concurrency.IScheduler)">
            <summary>特定の要素を無限に繰り返す監視可能なシーケンスを生成し、指定された Scheduler を使用してオブザーバー メッセージを送信します。</summary>
            <typeparam name="TResult">生成されたシーケンスで繰り返される要素のタイプ。</typeparam>
            <param name="value">繰り返す要素。</param>
            <param name="scheduler">プロデューサー ループを実行する Scheduler。</param>
            <returns>特定の要素を無限に繰り返す監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Int32)">
            <summary>特定の要素を指定された回数繰り返す監視可能なシーケンスを生成します。</summary>
            <typeparam name="TResult">生成されたシーケンスで繰り返される要素のタイプ。</typeparam>
            <param name="value">繰り返す要素。</param>
            <param name="repeatCount">要素を繰り返す回数。</param>
            <returns>特定の要素を指定された回数繰り返す監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(``0,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>特定の要素を指定された回数繰り返す監視可能なシーケンスを生成し、指定された Scheduler を使用してオブザーバー メッセージを送信します。</summary>
            <typeparam name="TResult">生成されたシーケンスで繰り返される要素のタイプ。</typeparam>
            <param name="value">繰り返す要素。</param>
            <param name="repeatCount">要素を繰り返す回数。</param>
            <param name="scheduler">プロデューサー ループを実行する Scheduler。</param>
            <returns>特定の要素を指定された回数繰り返す監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount"/> は 0 未満です。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Return``1(``0)">
            <summary>単一の要素を含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">生成されたシーケンスで返される要素のタイプ。</typeparam>
            <param name="value">結果として得られる監視可能なシーケンスの単一要素。</param>
            <returns>指定された単一の要素を含む監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Return``1(``0,System.Reactive.Concurrency.IScheduler)">
            <summary>オブザーバー メッセージを送信するために指定された Scheduler を使用して、単一の要素を含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">生成されたシーケンスで返される要素のタイプ。</typeparam>
            <param name="value">結果として得られる監視可能なシーケンスの単一要素。</param>
            <param name="scheduler">単一の要素を送信する Scheduler。</param>
            <returns>指定された単一の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)">
            <summary>例外で終了する監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプ パラメーターに使用されるタイプ。</typeparam>
            <param name="exception">シーケンスの終了に使用される例外オブジェクト。</param>
            <returns>指定された例外オブジェクトを使用して例外的に終了する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception,``0)">
            <summary>例外で終了する監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプ パラメーターに使用されるタイプ。</typeparam>
            <param name="exception">シーケンスの終了に使用される例外オブジェクト。</param>
            <param name="witness"><typeparamref name="TResult"/> タイプを推測するためにのみ使用されるオブジェクト。このパラメーターは通常、匿名でタイプ指定された要素のシーケンスを作成するときに使用されます。</param>
            <returns>指定された例外オブジェクトを使用して例外的に終了する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception,System.Reactive.Concurrency.IScheduler)">
            <summary>単一の OnError メッセージを送信するために指定された Scheduler を使用し、例外で終了する監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプ パラメーターに使用されるタイプ。</typeparam>
            <param name="exception">シーケンスの終了に使用される例外オブジェクト。</param>
            <param name="scheduler">例外的な終了コールを送信する Scheduler。</param>
            <returns>指定された例外オブジェクトを使用して例外的に終了する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throw``1(System.Exception,System.Reactive.Concurrency.IScheduler,``0)">
            <summary>単一の OnError メッセージを送信するために指定された Scheduler を使用し、例外で終了する監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">結果のシーケンスの IObservable&lt;T&gt; タイプ パラメーターに使用されるタイプ。</typeparam>
            <param name="exception">シーケンスの終了に使用される例外オブジェクト。</param>
            <param name="scheduler">例外的な終了コールを送信する Scheduler。</param>
            <param name="witness"><typeparamref name="TResult"/> タイプを推測するためにのみ使用されるオブジェクト。このパラメーターは通常、匿名でタイプ指定された要素のシーケンスを作成するときに使用されます。</param>
            <returns>指定された例外オブジェクトを使用して例外的に終了する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="exception"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Using``2(System.Func{``1},System.Func{``1,System.IObservable{``0}})">
            <summary>有効期間が結果の監視可能なシーケンスの有効期間に関連付けられており、リソース オブジェクトに依存する監視可能なシーケンスを構築します。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResource">結果のシーケンスの生成時に使用されるリソースのタイプ。<see cref="T:System.IDisposable"/> を実装する必要があります。</typeparam>
            <param name="resourceFactory">リソース オブジェクトを取得するファクトリ関数。</param>
            <param name="observableFactory">取得したリソースに依存する監視可能なシーケンスを取得するファクトリ関数。</param>
            <returns>依存するリソース オブジェクトの有効期間を制御する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="resourceFactory"/> または <paramref name="observableFactory"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Using``2(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Func{``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.IObservable{``0}}})">
            <summary>有効期間が結果の監視可能なシーケンスの有効期間に関連付けられており、リソース オブジェクトに依存する監視可能なシーケンスを構築します。リソースは、非同期メソッドを使用して取得および使用されます。非同期メソッドに渡される CancellationToken は、返される破棄可能なサブスクリプションに関連付けられているため、リソースの取得または使用の任意の段階でベスト エフォートの取り消しが可能になります。</summary>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResource">結果のシーケンスの生成時に使用されるリソースのタイプ。<see cref="T:System.IDisposable"/> を実装する必要があります。</typeparam>
            <param name="resourceFactoryAsync">リソース オブジェクトを取得する非同期ファクトリ関数。</param>
            <param name="observableFactoryAsync">取得したリソースに依存する監視可能なシーケンスを取得する非同期ファクトリ関数。</param>
            <returns>依存するリソース オブジェクトの有効期間を制御する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="resourceFactoryAsync"/> または <paramref name="observableFactoryAsync"/> は null です。</exception>
            <remarks>この演算子は、C# 5.0 および Visual Basic 11 で導入された非同期プログラミング機能と組み合わせると特に役立ちます。</remarks>
            <remarks>結果のシーケンスへのサブスクリプションが破棄されると、非同期リソース ファクトリおよび監視可能なファクトリ関数に供給された CancellationToken が通知されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.And``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>両方の監視可能なシーケンスに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TLeft">左シーケンスの要素のタイプ。</typeparam>
            <typeparam name="TRight">右シーケンスの要素のタイプ。</typeparam>
            <param name="left">右シーケンスと一致する監視可能なシーケンス。</param>
            <param name="right">左シーケンスと一致する監視可能なシーケンス。</param>
            <returns>両方の監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> または <paramref name="right"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Then``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">セレクターを適用する監視可能なシーケンス。</param>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.When``1(System.Reactive.Joins.Plan{``0}[])">
            <summary>複数のパターンの結果を結合します。</summary>
            <typeparam name="TResult">指定されたパターンから取得した結果シーケンス内の要素のタイプ。</typeparam>
            <param name="plans">パターン上の Then 演算子を使用して作成された一連の計画。</param>
            <returns>複数のパターンを照合した結果を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="plans"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.When``1(System.Collections.Generic.IEnumerable{System.Reactive.Joins.Plan{``0}})">
            <summary>複数のパターンの結果を結合します。</summary>
            <typeparam name="TResult">指定されたパターンから取得した結果シーケンス内の要素のタイプ。</typeparam>
            <param name="plans">パターン上の Then 演算子を使用して作成された一連の計画。</param>
            <returns>複数のパターンに一致する結果フォームを持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="plans"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>最初に反応する監視可能なシーケンスを伝達します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なシーケンス。</param>
            <param name="second">2 番目の監視可能なシーケンス。</param>
            <returns>特定のシーケンスのいずれかを明らかにする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0}[])">
            <summary>最初に反応する監視可能なシーケンスを伝播します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">最初に反応するために競合する監視可能なソース。</param>
            <returns>特定のシーケンスでいずれか速く反応する方を明らかにする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Amb``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>最初に反応する監視可能なシーケンスを伝播します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">最初に反応するために競合する監視可能なソース。</param>
            <returns>特定のシーケンスでいずれか速く反応する方を明らかにする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``2(System.IObservable{``0},System.Func{System.IObservable{``1}})">
            <summary>監視可能なシーケンスの各要素を、重複しない連続したバッファーに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <typeparam name="TBufferClosing">バッファー終了イベントを示すシーケンス内の要素のタイプ。</typeparam>
            <param name="source">バッファー オーバーを生成するソースシーケンス。</param>
            <param name="bufferClosingSelector">生成されたバッファーの境界を定義するために呼び出される関数。前のバッファーが閉じられると、新しいバッファーが開始されます。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="bufferClosingSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``3(System.IObservable{``0},System.IObservable{``1},System.Func{``1,System.IObservable{``2}})">
            <summary>監視可能なシーケンスの各要素を 0 個以上のバッファーに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <typeparam name="TBufferOpening">バッファー開始イベントを示し、終了セレクターに渡してバッファー終了イベントのシーケンスを取得するシーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TBufferClosing">バッファー終了イベントを示すシーケンス内の要素のタイプ。</typeparam>
            <param name="source">バッファー オーバーを生成するソースシーケンス。</param>
            <param name="bufferOpenings">要素が新しいバッファーの作成を示す監視可能なシーケンス。</param>
            <param name="bufferClosingSelector">生成された各バッファーの終了を定義するために呼び出される関数。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="bufferOpenings"/> あるいは <paramref name="bufferClosingSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>監視可能なシーケンスの各要素を、重複しない連続したバッファーに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <typeparam name="TBufferBoundary">バッファー境界イベントを示すシーケンス内の要素のタイプ。</typeparam>
            <param name="source">バッファー オーバーを生成するソースシーケンス。</param>
            <param name="bufferBoundaries">バッファー境界マーカーのシーケンス。現在のバッファーは閉じ、境界マーカーを受け取ると新しいバッファーが開きます。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="bufferBoundaries"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``2(System.IObservable{``0},System.Func{``1,System.IObservable{``0}})">
            <summary>指定されたタイプの例外によって終了される監視可能なシーケンスを、ハンドラーによって生成された監視可能なシーケンスで続けます。</summary>
            <typeparam name="TSource">ソース シーケンスと、例外ハンドラー関数によって返されるシーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TException">捕捉して処理する例外のタイプ。<see cref="T:System.Exception"/> から派生する必要があります。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="handler">別の監視可能なシーケンスを生成する例外ハンドラー関数。</param>
            <returns>ソース シーケンスの要素を含む監視可能なシーケンス。例外が発生した場合にハンドラーの結果として得られる監視可能なシーケンスによって生成される要素がその後に続きます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="handler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>次の監視可能シーケンスを使用して例外によって終了する監視可能なシーケンスを続行します。</summary>
            <typeparam name="TSource">ソース シーケンスとハンドラー シーケンス内の要素のタイプ。</typeparam>
            <param name="first">例外 (該当する場合) が捕捉される最初の監視可能なシーケンス。</param>
            <param name="second">最初のシーケンスでエラーが発生した際、結果を生成するために使用される 2 番目の監視可能なシーケンス。</param>
            <returns>最初のシーケンスの要素を含む観測可能なシーケンス。例外が発生した場合に 2 番目のシーケンスの要素がその後に続きます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``1(System.IObservable{``0}[])">
            <summary>次の監視可能シーケンスを使用して例外によって終了する監視可能なシーケンスを続行します。</summary>
            <typeparam name="TSource">ソース シーケンスとハンドラー シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">例外を捕捉するための監視可能なシーケンス。</param>
            <returns>ソース シーケンスが正常に終了するまで、連続するソース シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Catch``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>次の監視可能シーケンスを使用して例外によって終了する監視可能なシーケンスを続行します。</summary>
            <typeparam name="TSource">ソース シーケンスとハンドラー シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">例外を捕捉するための監視可能なシーケンス。</param>
            <returns>ソース シーケンスが正常に終了するまで、連続するソース シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})">
            <summary>監視可能なシーケンスの 1 つが要素を生成するたびに、選択関数を使用して、2 つの監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なソース。</param>
            <param name="second">2 番目の監視可能なソース。</param>
            <param name="resultSelector">いずれかのソースが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用して両方のソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``4(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Func{``0,``1,``2,``3})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または <paramref name="source2"/> あるいは <paramref name="source3"/> もしくは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``5(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または <paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="resultSelector"/> は null です。   </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``6(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または <paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="resultSelector"/> は null です。    </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``7(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``8(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``9(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="resultSelector"/> は null です。       </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``10(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="resultSelector"/> は null です。        </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``11(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="resultSelector"/> は null です。         </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``12(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="resultSelector"/> は null です。          </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``13(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="resultSelector"/> は null です。           </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``14(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="resultSelector"/> は null です。            </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``15(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="source14">14 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="source14"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``16(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource15">15 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="source14">14 番目の監視可能なソース。</param>
            <param name="source15">15 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="source14"/>、<paramref name="source15"/>、<paramref name="resultSelector"/> は null です。              </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``17(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.IObservable{``15},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource15">15 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource16">16 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="source14">14 番目の監視可能なソース。</param>
            <param name="source15">15 番目の監視可能なソース。</param>
            <param name="source16">16 番目の監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="source14"/>、<paramref name="source15"/>、<paramref name="source16"/>、<paramref name="resultSelector"/> は null です。               </exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{System.Collections.Generic.IList{``0},``1})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なソース。</param>
            <param name="resultSelector">ソースのいずれかが要素を生成するたびに呼び出す関数。効率を上げるため、セレクターが返した後の入力リストを再利用します。関数の呼び出し中に値を集計するかコピーします。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> または <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに最新のソース要素でリストを出力して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリストの要素のタイプ。</typeparam>
            <param name="sources">監視可能なソース。</param>
            <returns>ソースの最新要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.CombineLatest``1(System.IObservable{``0}[])">
            <summary>監視可能なシーケンスのいずれかが要素を生成するたびに最新のソース要素でリストを出力して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリストの要素のタイプ。</typeparam>
            <param name="sources">監視可能なソース。</param>
            <returns>ソースの最新要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>最初の監視可能なシーケンスが正常に終了した後、2 番目の監視可能なシーケンスを最初の監視可能なシーケンスに連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なシーケンス。</param>
            <param name="second">2 番目の監視可能なシーケンス。</param>
            <returns>最初のシーケンスの要素を含む監視可能なシーケンス。その後に 2 番目のシーケンスの要素が続きます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{``0}[])">
            <summary>前の監視可能なシーケンスが正常に終了した場合に限り、指定された監視可能なシーケンスをすべて連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">連結する監視可能なシーケンス。</param>
            <returns>特定の各シーケンスの要素を順番に含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>前の監視可能なシーケンスが正常に終了した場合に限り、特定の列挙可能なシーケンスですべての監視可能なシーケンスを連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">連結する監視可能なシーケンス。</param>
            <returns>特定の各シーケンスの要素を順番に含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{System.IObservable{``0}})">
            <summary>前の監視可能なシーケンスが正常に終了した場合に限り、すべての内部監視可能シーケンスを連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">内部監視可能シーケンスの監視可能なシーケンス。</param>
            <returns>監視された各内部シーケンスの要素を順番に含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{System.Threading.Tasks.Task{``0}})">
            <summary>前のタスクが正常に終了した場合に限り、すべてのタスク結果を連結します。</summary>
            <typeparam name="TSource">タスクによって生成される結果のタイプ。</typeparam>
            <param name="sources">タスクの監視可能なシーケンス。</param>
            <returns>各タスクの結果を順番に含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
            <remarks>タスクが取り消しをサポートしている場合は、<see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/> を使用した後、<see cref="M:System.Reactive.Linq.Observable.Concat``1(System.IObservable{System.IObservable{``0}})"/> を使用して連結操作を行うタスクの手動変換を検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})">
            <summary>すべての内部監視可能シーケンスの要素を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">内部監視可能シーケンスの監視可能なシーケンス。</param>
            <returns>内部シーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.Threading.Tasks.Task{``0}})">
            <summary>すべてのソース タスクの結果を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース タスクによって生成される結果のタイプ。</typeparam>
            <param name="sources">タスクの監視可能なシーケンス。</param>
            <returns>ソース タスクの結果をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
            <remarks>タスクが取り消しをサポートしている場合は、<see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/> を使用した後、 <see cref="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}})"/> を使用してマージ操作を行う手動変換を検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{System.IObservable{``0}},System.Int32)">
            <summary>すべての内部監視可能シーケンスの要素を単一の監視可能なシーケンスにマージし、内部シーケンスへの同時サブスクリプション数を制限します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">内部監視可能シーケンスの監視可能なシーケンス。</param>
            <param name="maxConcurrent">同時にサブスクライブされる内部監視可能シーケンスの最大数。</param>
            <returns>内部シーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxConcurrent"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Int32)">
            <summary>特定の列挙可能なシーケンス内のすべての監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージし、同時サブスクリプションの数を内部シーケンスに制限します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なシーケンスの列挙可能なシーケンス。</param>
            <param name="maxConcurrent">同時にサブスクライブされる監視可能なシーケンスの最大数。</param>
            <returns>監視可能なシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxConcurrent"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>特定の列挙可能なシーケンス内のすべての監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージし、同時サブスクリプションの数を内部シーケンスに制限して、ソースの列挙とソースへのサブスクリプション向けに指定された Scheduler を使用します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なシーケンスの列挙可能なシーケンス。</param>
            <param name="maxConcurrent">同時にサブスクライブされる監視可能なシーケンスの最大数。</param>
            <param name="scheduler">ソースのシーケンスの列挙を実行する Scheduler。</param>
            <returns>監視可能なシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxConcurrent"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>2 つの監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なシーケンス。</param>
            <param name="second">2 番目の監視可能なシーケンス。</param>
            <returns>特定のシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0},System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>ソースの列挙およびソースへのサブスクリプション向けに指定された Scheduler を使用して、2 つの監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なシーケンス。</param>
            <param name="second">2 番目の監視可能なシーケンス。</param>
            <param name="scheduler">特定のシーケンスへのサブスクリプションを作成するための同時導入で使用される Scheduler。</param>
            <returns>特定のシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> あるいは <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.IObservable{``0}[])">
            <summary>指定されたすべてのアンしか能なシーケンスの要素を単一つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なシーケンス。</param>
            <returns>監視可能なシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Reactive.Concurrency.IScheduler,System.IObservable{``0}[])">
            <summary>ソースの列挙およびソースへのサブスクリプション向けに指定された Scheduler を使用して、指定されたすべての監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なシーケンス。</param>
            <param name="scheduler">ソースのシーケンスの列挙を実行する Scheduler。</param>
            <returns>監視可能なシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> または <paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>特定の列挙可能なシーケンス内のあらゆる監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なシーケンスの列挙可能なシーケンス。</param>
            <returns>監視可能なシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Merge``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>ソースの列挙およびソースへのサブスクリプション向けに指定された Schdeuler を使用して、特定の列挙可能なシーケンス内のあらゆる監視可能なシーケンスの要素を単一の監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なシーケンスの列挙可能なシーケンス。</param>
            <param name="scheduler">ソースのシーケンスの列挙を実行する Scheduler。</param>
            <returns>監視可能なシーケンスの要素をマージする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OnErrorResumeNext``1(System.IObservable{``0},System.IObservable{``0})">
            <summary>最初の監視可能なシーケンスが成功した後、またはこれが例外的に終了した後、2 番目の監視可能なシーケンスを最初の監視可能なシーケンスに連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="first">例外 (該当する場合) が捕捉される最初の監視可能なシーケンス。</param>
            <param name="second">最初のシーケンスが終了した後に結果を生成するために使用される 2 番目の監視可能なシーケンス。</param>
            <returns>最初のシーケンスが例外的に終了した場合でも、最初のシーケンスと 2 番目のシーケンスを連結する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OnErrorResumeNext``1(System.IObservable{``0}[])">
            <summary>前の監視可能なシーケンスが例外的に終了した場合でも、指定された監視可能なシーケンスをすべて連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">連結する監視可能なシーケンス。</param>
            <returns>シーケンスが例外的に終了した場合でも、ソース シーケンスを連結する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OnErrorResumeNext``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>前の監視可能なシーケンスが例外的に終了した場合でも、特定の列挙可能なシーケンスで監視可能なシーケンスをすべて連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">連結する監視可能なシーケンス。</param>
            <returns>シーケンスが例外的に終了した場合でも、ソース シーケンスを連結する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipUntil``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>他の監視可能なシーケンスが要素を生成した後にのみ、ソースの監視可能なシーケンスから要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TOther">スキップ動作の終了を示す他のシーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を伝播するソース シーケンス。</param>
            <param name="other">ソース シーケンスの要素の伝達をトリガーする監視可能なシーケンス。</param>
            <returns>他のシーケンスが伝達をトリガーした時点から始まるソース シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.IObservable{``0}})">
            <summary>複数の監視可能なシーケンスの単一の監視可能なシーケンスを、最新の監視可能なシーケンスからのみ値を生成する監視可能なシーケンスに変換します。新しい内部監視可能シーケンスを受け取るたびに、前の内部監視可能シーケンスのサブスクライブを解除します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">内部監視可能シーケンスの監視可能なシーケンス。</param>
            <returns>受け取った最新の内部監視可能シーケンスの要素を任意の時点で生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.Threading.Tasks.Task{``0}})">
            <summary>タスクの監視可能なシーケンスを、最新の監視可能なシーケンスからのみ値を生成する監視可能なシーケンスに変換します。新しいタスクを受け取るたびに、前のタスクの結果は無視されます。</summary>
            <typeparam name="TSource">ソース タスクによって生成される結果のタイプ。</typeparam>
            <param name="sources">タスクの監視可能なシーケンス。</param>
            <returns>受け取った最新のタスクの結果を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
            <remarks>タスクが取り消しをサポートしている場合は、<see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/> を使用した後、<see cref="M:System.Reactive.Linq.Observable.Switch``1(System.IObservable{System.IObservable{``0}})"/> を使用して切り替え操作を行う手動変換を検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeUntil``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>他の監視可能なシーケンスが要素を生成するまで、ソースの監視可能なシーケンスから要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TOther">取得動作の終了を示す他のシーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を伝達するソース シーケンス。</param>
            <param name="other">ソース シーケンスの要素の伝達を終了する監視可能なシーケンス。</param>
            <returns>他のシーケンスがさらなる伝達を阻止した時点までのソースシーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``2(System.IObservable{``0},System.Func{System.IObservable{``1}})">
            <summary>監視可能なシーケンスの各要素を、重複しない連続したウィンドウに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <typeparam name="TWindowClosing">ウィンドウの終了イベントを示すシーケンス内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="windowClosingSelector">生成されたウィンドウの境界を定義するために呼び出される関数。前のウィンドウが閉じられると、新しいウィンドウが開始されます。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="windowClosingSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``3(System.IObservable{``0},System.IObservable{``1},System.Func{``1,System.IObservable{``2}})">
            <summary>監視可能なシーケンスの各要素をゼロ以上のウィンドウに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <typeparam name="TWindowOpening">ウィンドウを開くイベントを示すシーケンス内の要素のタイプ。ウィンドウを閉じるイベントのシーケンスを取得するために閉じるセレクターにも渡されます。</typeparam>
            <typeparam name="TWindowClosing">ウィンドウの終了イベントを示すシーケンス内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="windowOpenings">要素が新しいウィンドウの作成を示す監視可能なシーケンス。</param>
            <param name="windowClosingSelector">生成された各ウィンドウの終了を定義するために呼び出される関数。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="windowOpenings"/> あるいは <paramref name="windowClosingSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>監視可能なシーケンスの各要素を、重複しない連続したウィンドウに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <typeparam name="TWindowBoundary">ウィンドウ境界イベントを示すシーケンス内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="windowBoundaries">ウィンドウ境界マーカーのシーケンス。現在のウィンドウが閉じられ、境界マーカーを受け取ると新しいウィンドウが開きます。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="windowBoundaries"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``3(System.IObservable{``0},System.IObservable{``1},System.Func{``0,``1,``2})">
            <summary>要素をペアで組み合わせ、2 つの監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なソース。</param>
            <param name="second">2 番目の監視可能なソース。</param>
            <param name="resultSelector">最初と 2 番目のソースから要素の連続したペアごとに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用して、最初のソースと 2 番目のソースの要素をペアで組み合わせた結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``4(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Func{``0,``1,``2,``3})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または <paramref name="source2"/> あるいは <paramref name="source3"/> もしくは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``5(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または <paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``6(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または <paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``7(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.Func{``0,``1,``2,``3,``4,``5,``6})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``8(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``9(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``10(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``11(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``12(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``13(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``14(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``15(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="source14">14 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="source14"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``16(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource15">15 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="source14">14 番目の監視可能なソース。</param>
            <param name="source15">15 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="source14"/>、<paramref name="source15"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``17(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.IObservable{``3},System.IObservable{``4},System.IObservable{``5},System.IObservable{``6},System.IObservable{``7},System.IObservable{``8},System.IObservable{``9},System.IObservable{``10},System.IObservable{``11},System.IObservable{``12},System.IObservable{``13},System.IObservable{``14},System.IObservable{``15},System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource15">15 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource16">16 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source1">最初の監視可能なソース。</param>
            <param name="source2">2 番目の監視可能なソース。</param>
            <param name="source3">3 番目の監視可能なソース。</param>
            <param name="source4">4 番目の監視可能なソース。</param>
            <param name="source5">5 番目の監視可能なソース。</param>
            <param name="source6">6 番目の監視可能なソース。</param>
            <param name="source7">7 番目の監視可能なソース。</param>
            <param name="source8">8 番目の監視可能なソース。</param>
            <param name="source9">9 番目の監視可能なソース。</param>
            <param name="source10">10 番目の監視可能なソース。</param>
            <param name="source11">11 番目の監視可能な情報源。</param>
            <param name="source12">12 番目の監視可能なソース。</param>
            <param name="source13">13 番目の監視可能な情報源。</param>
            <param name="source14">14 番目の監視可能なソース。</param>
            <param name="source15">15 番目の監視可能なソース。</param>
            <param name="source16">16 番目の監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source1"/> または、<paramref name="source2"/>、<paramref name="source3"/>、<paramref name="source4"/>、<paramref name="source5"/>、<paramref name="source6"/>、<paramref name="source7"/>、<paramref name="source8"/>、<paramref name="source9"/>、<paramref name="source10"/>、<paramref name="source11"/>、<paramref name="source12"/>、<paramref name="source13"/>、<paramref name="source14"/>、<paramref name="source15"/>、<paramref name="source16"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``2(System.Collections.Generic.IEnumerable{System.IObservable{``0}},System.Func{System.Collections.Generic.IList{``0},``1})">
            <summary>すべての監視可能なシーケンスが対応するインデックスで要素を生成するたびに、選択関数を使用して、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="sources">監視可能なソース。</param>
            <param name="resultSelector">ソース内の対応するインデックスで要素の各系列を呼び出す関数。</param>
            <returns>指定された結果選択関数を使用してソースの要素を結合した結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> または <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``1(System.Collections.Generic.IEnumerable{System.IObservable{``0}})">
            <summary>対応するインデックスで監視可能なシーケンスの要素を含むリストを出力し、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリストの要素のタイプ。</typeparam>
            <param name="sources">監視可能なソース。</param>
            <returns>対応するインデックスの要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``1(System.IObservable{``0}[])">
            <summary>対応するインデックスで監視可能なシーケンスの要素を含むリストを出力し、指定された監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリストの要素のタイプ。</typeparam>
            <param name="sources">監視可能なソース。</param>
            <returns>対応するインデックスの要素のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="sources"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Zip``3(System.IObservable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>選択使用して、監視可能なシーケンスと列挙可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource1">最初の監視可能なソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目の列挙可能なソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="first">最初の監視可能なソース。</param>
            <param name="second">2 番目の列挙可能なソース。</param>
            <param name="resultSelector">最初と 2 番目のソースから要素の連続したペアごとに呼び出す関数。</param>
            <returns>指定された結果選択関数を使用して、最初のソースと 2 番目のソースの要素をペアで組み合わせた結果を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="first"/> または <paramref name="second"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.AsObservable``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの ID を非表示にします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ID を非表示にする監視可能なシーケンス。</param>
            <returns>ソース シーケンスの ID を非表示にする監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスの各要素を、要素カウント情報に基づいて生成される連続した重複しないバッファーに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="count">各バッファーの長さ。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.Int32,System.Int32)">
            <summary>監視可能なシーケンスの各要素を、要素カウント情報に基づいて生成される 0 個以上のバッファーに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="count">各バッファーの長さ。</param>
            <param name="skip">連続するバッファーの作成の間にスキップする要素の数。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> または <paramref name="skip"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">
            <summary>監視可能なシーケンスの明示的な通知値を非具体化して暗黙的な通知にします。</summary>
            <typeparam name="TSource">ソース シーケンス通知オブジェクトで具体化された要素のタイプ。</typeparam>
            <param name="source">暗黙的な通知に変換する必要がある明示的な通知値を含む監視可能なシーケンス。</param>
            <returns>ソース シーケンスの通知値に対応する動作を示す監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``1(System.IObservable{``0})">
            <summary>明確な連続する要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">明確な連続する要素を保持するための監視可能なシーケンス。</param>
            <returns>ソース シーケンスの明確な連続する要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``1(System.IObservable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>比較関数に従って、明確な連続する要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">明確な連続する要素を保持するための監視可能なシーケンス。</param>
            <param name="comparer">ソース要素の等値比較関数。</param>
            <returns>ソース シーケンスの明確な連続する要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>keySelector に従って明確な連続する要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される識別子キーのタイプ。</typeparam>
            <param name="source">計算されたキー値に基づいて、明確な連続する要素を保持するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素の比較キーを計算する関数。</param>
            <returns>計算されたキー値に基づいて、ソース シーケンスからの明確な連続する要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DistinctUntilChanged``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>keySelector と比較関数に従って、明確な連続する要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される識別子キーのタイプ。</typeparam>
            <param name="source">計算されたキー値に基づいて、明確な連続する要素を保持するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素の比較キーを計算する関数。</param>
            <param name="comparer">計算されたキー値の等値比較関数。</param>
            <returns>計算されたキー値に基づいて、ソース シーケンスからの明確な連続する要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0})">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、結果シーケンスを介して、すべての監視可能なメッセージを伝達します。このメソッドは、パイプライン上のメッセージに対して任意のアクションを実行するためにメッセージ ストリームをインターセプトすることにより、クエリ動作のデバッグやロギングなどに使用できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <returns>副作用の動作が適用されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0},System.Action)">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、監視可能なシーケンスの正常な終了時にアクションを呼び出します。このメソッドは、パイプライン上のメッセージに対して任意のアクションを実行するためにメッセージ ストリームをインターセプトすることにより、クエリ動作のデバッグやロギングなどに使用できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <param name="onCompleted">監視可能なシーケンスの正常な終了時に呼び出すアクション。</param>
            <returns>副作用の動作が適用されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> あるいは <paramref name="onCompleted"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、監視可能シーケンスの例外的な終了時にアクションを呼び出します。このメソッドは、パイプライン上のメッセージに対して任意のアクションを実行するためにメッセージ ストリームをインターセプトすることにより、クエリ動作のデバッグやロギングなどに使用できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <param name="onError">監視可能なシーケンスの例外的な終了時に呼び出すアクション。</param>
            <returns>副作用の動作が適用されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> あるいは <paramref name="onError"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.Action{``0},System.Action{System.Exception},System.Action)">
            <summary>監視可能なシーケンス内の各要素に対してアクションを呼び出し、監視可能なシーケンスの正常な終了または例外的な終了時にアクションを呼び出します。このメソッドは、パイプライン上のメッセージに対して任意のアクションを実行するためにメッセージ ストリームをインターセプトすることにより、クエリ動作のデバッグやロギングなどに使用できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="onNext">監視可能なシーケンスで各要素に対して呼び出すアクション。</param>
            <param name="onError">監視可能なシーケンスの例外的な終了時に呼び出すアクション。</param>
            <param name="onCompleted">監視可能なシーケンスの正常な終了時に呼び出すアクション。</param>
            <returns>副作用の動作が適用されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> あるいは <paramref name="onError"/> もしくは <paramref name="onCompleted"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Do``1(System.IObservable{``0},System.IObserver{``0})">
            <summary>ソース シーケンス内の各メッセージに対してオブザーバーのメソッドを呼び出します。このメソッドは、パイプライン上のメッセージに対して任意のアクションを実行するためにメッセージ ストリームをインターセプトすることにより、クエリ動作のデバッグやロギングなどに使用できます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="observer">ソース シーケンスの監視の一部としてメソッドを呼び出すオブザーバー。</param>
            <returns>副作用の動作が適用されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="observer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Finally``1(System.IObservable{``0},System.Action)">
            <summary>ソースの監視可能なシーケンスが正常に終了した後、または例外的に終了した後に、指定されたアクションを呼び出します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="finallyAction">ソースの監視可能なシーケンスが終了した後に呼び出すアクション。</param>
            <returns>アクション呼び出し終了動作が適用されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="finallyAction"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.IgnoreElements``1(System.IObservable{``0})">
            <summary>終了メッセージのみを残して、監視可能なシーケンス内のすべての要素を無視します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <returns>成功か例外かに関わらず、ソース シーケンスの終了を通知する空の監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスの暗黙的な通知を明示的な通知値として具体化します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">通知値を取得するための監視可能なシーケンス。</param>
            <returns>ソース シーケンスからの具体化された通知値を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(System.IObservable{``0})">
            <summary>監視可能なシーケンスを無期限に繰り返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">繰り返される監視可能なシーケンス。</param>
            <returns>特定のシーケンスの要素を繰り返し連続して生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Repeat``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスを指定した回数繰り返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">繰り返される監視可能なシーケンス。</param>
            <param name="repeatCount">シーケンスを繰り返す回数。</param>
            <returns>特定のシーケンスの要素を繰り返し生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Retry``1(System.IObservable{``0})">
            <summary>ソースの監視可能なシーケンスが正常に終了するまで繰り返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">正常に終了するまで繰り返される監視可能なシーケンス。</param>
            <returns>正常に終了するまで特定のシーケンスの要素を繰り返し生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Retry``1(System.IObservable{``0},System.Int32)">
            <summary>指定された回数または正常に終了するまでソースの監視可能なシーケンスを繰り返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">正常に終了するまで繰り返される監視可能なシーケンス。</param>
            <param name="retryCount">シーケンスを繰り返す回数。</param>
            <returns>正常に終了するまで特定のシーケンスの要素を繰り返し生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retryCount"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Scan``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})">
            <summary>監視可能なシーケンスにアキュムレータ関数を適用し、各中間結果を返します。指定されたシード値は、初期アキュムレータ値として使用されます。中間結果のない集計動作については、 <see cref="M:System.Reactive.Linq.Observable.Aggregate``2(System.IObservable{``0},``1,System.Func{``1,``0,``1})"/>を参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TAccumulate">集計の結果のタイプ。</typeparam>
            <param name="source">累積する監視可能なシーケンス。</param>
            <param name="seed">初期アキュムレータ値。</param>
            <param name="accumulator">各要素で呼び出されるアキュムレータ関数。</param>
            <returns>累積値を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="accumulator"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Scan``1(System.IObservable{``0},System.Func{``0,``0,``0})">
            <summary>監視可能なシーケンスにアキュムレータ関数を適用し、各中間結果を返します。中間結果のない集計動作については、 <see cref="M:System.Reactive.Linq.Observable.Aggregate``1(System.IObservable{``0},System.Func{``0,``0,``0})"/>を参照してください。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプと集計の結果。</typeparam>
            <param name="source">累積する監視可能なシーケンス。</param>
            <param name="accumulator">各要素で呼び出されるアキュムレータ関数。</param>
            <returns>累積値を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="accumulator"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスの末尾で、指定された数の要素をバイパスします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="count">ソース シーケンスの末尾でバイパスされる要素の数。</param>
            <returns>ソース シーケンス要素を含む監視可能なシーケンス (最後にバイパスされた要素は除きます)。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
            <remarks>この演算子は、最初の <paramref name="count"/> 要素を格納するのに十分な長さのキューを累積します。より多くの要素を受け取ると、要素はキューの先頭から取得され、結果シーケンスで生成されます。これにより、要素が遅延します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},``0[])">
            <summary>一連の値を監視可能なシーケンスの先頭に追加します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を先頭に追加するソース シーケンス。</param>
            <param name="values">指定されたシーケンスの先頭に先頭に追加する値。</param>
            <returns>指定された値が先頭に追加されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="values"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>一連の値を監視可能なシーケンスの先頭に追加します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を先頭に追加するソース シーケンス。</param>
            <param name="values">指定されたシーケンスの先頭に先頭に追加する値。</param>
            <returns>指定された値が先頭に追加されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="values"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler,``0[])">
            <summary>一連の値を監視可能なシーケンスの先頭に追加します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を先頭に追加するソース シーケンス。</param>
            <param name="scheduler">先頭に追加される値を生成する Scheduler。</param>
            <param name="values">指定されたシーケンスの先頭に先頭に追加する値。</param>
            <returns>指定された値が先頭に追加されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> あるいは <paramref name="values"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.StartWith``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler,System.Collections.Generic.IEnumerable{``0})">
            <summary>一連の値を監視可能なシーケンスの先頭に追加します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を先頭に追加するソース シーケンス。</param>
            <param name="scheduler">先頭に追加される値を生成する Scheduler。</param>
            <param name="values">指定されたシーケンスの先頭に先頭に追加する値。</param>
            <returns>指定された値が先頭に追加されたソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> あるいは <paramref name="values"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスの末尾から指定された数の連続する要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="count">ソース シーケンスの末尾から取得する要素の数。</param>
            <returns>ソース シーケンスの末尾から指定された数の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
            <remarks>この演算子は、 <paramref name="count"/> 要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスでドレインされます。これにより、要素が遅延します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>監視可能なシーケンスの末尾から指定された数の連続する要素を返し、指定された Scheduler を使用してキューをドレインします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="count">ソース シーケンスの末尾から取得する要素の数。</param>
            <param name="scheduler">ソース シーケンスの完了時にキューをドレインするために使用される Scheduler。</param>
            <returns>ソース シーケンスの末尾から指定された数の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
            <remarks>この演算子は、 <paramref name="count"/> 要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスでドレインされます。これにより、要素が遅延します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLastBuffer``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスの末尾から指定された数の連続する要素を含むリストを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">ソース シーケンス。</param>
            <param name="count">ソース シーケンスの末尾から取得する要素の数。</param>
            <returns>ソース シーケンスの末尾から指定された数の要素を持つ単一のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
            <remarks>この演算子は、<paramref name="count"/> 要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスで生成されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスの各要素を、要素カウント情報に基づいて生成される連続した重複しないウィンドウに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="count">各ウィンドウの長さ。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.Int32,System.Int32)">
            <summary>監視可能なシーケンスの各要素を、要素カウント情報に基づいて生成される 0 個以上のウィンドウに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="count">各ウィンドウの長さ。</param>
            <param name="skip">連続するウィンドウの作成の間にスキップする要素の数。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> または <paramref name="skip"/> は 0 以下です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Cast``1(System.IObservable{System.Object})">
            <summary>監視可能なシーケンスの要素を指定したタイプに変換します。</summary>
            <typeparam name="TResult">ソース シーケンス内の要素を変換するタイプ。</typeparam>
            <param name="source">変換する要素を含む監視可能なシーケンス。</param>
            <returns>指定されたタイプに変換されたソース シーケンスの各要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DefaultIfEmpty``1(System.IObservable{``0})">
            <summary>シーケンスが空の場合は、指定されたシーケンスの要素、または単一のシーケンスのタイプパラメーターの既定値を返します。</summary>
            <typeparam name="TSource">シーケンスが空の場合に既定値が取得されるソース シーケンス内の要素のタイプ (該当する場合) 。</typeparam>
            <param name="source">空の場合に既定値を返すシーケンス。</param>
            <returns>ソースが空の場合、TSource タイプの既定値を含む監視可能なシーケンス。それ以外の場合はソース自体の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DefaultIfEmpty``1(System.IObservable{``0},``0)">
            <summary>シーケンスが空の場合は、指定されたシーケンスの要素、または単一のシーケンスで指定された値をシーケンスで返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ (該当する場合)、およびシーケンスが空の場合に取得される指定された既定値。</typeparam>
            <param name="source">空の場合に指定された値を返すシーケンス。</param>
            <param name="defaultValue">シーケンスが空の場合に返す値。</param>
            <returns>ソースが空の場合に指定された既定値を含む監視可能なシーケンス。それ以外の場合はソース自体の要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``1(System.IObservable{``0})">
            <summary>明確な要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">明確な要素を保持するための監視可能なシーケンス。</param>
            <returns>ソース シーケンスの明確な要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>大きくなる可能性のある内部参照構造ではメンテナンスが必要なため、この演算子の使用は慎重に考慮する必要があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``1(System.IObservable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>比較関数に従って明確な要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">明確な要素を保持するための監視可能なシーケンス。</param>
            <param name="comparer">ソース要素の等値比較関数。</param>
            <returns>ソース シーケンスの明確な要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="comparer"/> は null です。</exception>
            <remarks>大きくなる可能性のある内部参照構造ではメンテナンスが必要なため、この演算子の使用は慎重に考慮する必要があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>keySelector に従って明確な要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される識別子キーのタイプ。</typeparam>
            <param name="source">明確な要素を保持するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素の比較キーを計算する関数。</param>
            <returns>計算されたキー値に基づき、ソース シーケンスからの明確な要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
            <remarks>大きくなる可能性のある内部参照構造ではメンテナンスが必要なため、この演算子の使用は慎重に考慮する必要があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Distinct``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>keySelector と比較関数に従って、明確な要素のみを含む監視可能なシーケンスを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算される識別子キーのタイプ。</typeparam>
            <param name="source">明確な要素を保持するための監視可能なシーケンス。</param>
            <param name="keySelector">各要素の比較キーを計算する関数。</param>
            <param name="comparer">ソース要素の等値比較関数。</param>
            <returns>計算されたキー値に基づき、ソース シーケンスからの明確な要素のみを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <remarks>大きくなる可能性のある内部参照構造ではメンテナンスが必要なため、この演算子の使用は慎重に考慮する必要があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>指定されたキー選択関数に従って、監視可能なシーケンスの要素をグループ化します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数と比較関数に従って、監視可能なシーケンスの要素をグループ化します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数と比較関数に従って監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> もしくは <paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1},System.Int32)">
            <summary>指定されたキー選択機能に従って、指定された初期容量を持つ監視可能なシーケンスの要素をグループ化します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``2(System.IObservable{``0},System.Func{``0,``1},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数および比較関数に従って、指定された初期容量のある監視可能なシーケンスの要素をグループ化します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="comparer"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Int32)">
            <summary>指定された初期容量を持つ監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupBy``3(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数および比較関数に従って、指定された初期容量を持つ監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> もしくは <paramref name="comparer"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数と比較関数に従って監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れると、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/>、<paramref name="elementSelector"/>、<paramref name="durationSelector"/>、<paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}})">
            <summary>指定されたキー選択関数に従って監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れた場合、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> もしくは <paramref name="durationSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数と比較関数に従って、監視可能なシーケンスの要素をグループ化します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れた場合、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="durationSelector"/> もしくは <paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}})">
            <summary>指定されたキー選択関数に従って、監視可能なシーケンスの要素をグループ化します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れた場合、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="durationSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数および比較関数に従って、指定された初期容量を持つ監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れると、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/>、<paramref name="elementSelector"/>、<paramref name="durationSelector"/>、<paramref name="comparer"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``4(System.IObservable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``2},System.IObservable{``3}},System.Int32)">
            <summary>指定されたキー選択関数に従って、指定された初期容量を持つ監視可能なシーケンスの要素をグループ化し、指定された関数を使用して結果の要素を選択します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TElement">ソース シーケンス内の各要素に対して計算されるグループ内の要素のタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="elementSelector">各ソース要素を監視可能なグループ内の要素にマップする関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れた場合、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="elementSelector"/> もしくは <paramref name="durationSelector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}},System.Int32,System.Collections.Generic.IEqualityComparer{``1})">
            <summary>指定されたキー選択関数および比較関数に従って、指定された初期容量のある監視可能なシーケンスの要素をグループ化します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <param name="comparer">キーを比較する等値比較関数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れた場合、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="durationSelector"/> もしくは <paramref name="comparer"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupByUntil``3(System.IObservable{``0},System.Func{``0,``1},System.Func{System.Reactive.Linq.IGroupedObservable{``1,``0},System.IObservable{``2}},System.Int32)">
            <summary>指定されたキー選択機能に従って、指定された初期容量を持つ監視可能なシーケンスの要素をグループ化します。期間選択関数は、グループの有効期間を制御するために使用されます。グループの有効期限が切れると、OnCompleted 通知が届きます。回収されたグループと同じキー値を持つ新しい要素が発生すると、グループは新しい有効期間の要求で生まれ変わります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TKey">ソース シーケンス内の各要素に対して計算されるグループ化キーのタイプ。</typeparam>
            <typeparam name="TDuration">有効期間を示す各グループで取得された期間シーケンス内の要素のタイプ。</typeparam>
            <param name="source">グループ化する要素を持つ監視可能なシーケンス。</param>
            <param name="keySelector">各要素のキーを抽出する関数。</param>
            <param name="durationSelector">グループの有効期限を通知する関数。</param>
            <param name="capacity">基になる辞書に含めることができる要素の初期数。</param>
            <returns>同じキー値を共有するすべての要素を含む、一意のキー値に対応する一連の監視可能なグループ。グループの有効期間が切れた場合、このようなキー値を持つ要素が検出されると、同じキー値を持つ新しいグループを作成できます。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="keySelector"/> あるいは <paramref name="durationSelector"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.GroupJoin``5(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``2}},System.Func{``1,System.IObservable{``3}},System.Func{``0,System.IObservable{``1},``4})">
            <summary>重複する期間に基づいて 2 つのシーケンスの要素を関連付け、結果をグループ化します。</summary>
            <typeparam name="TLeft">左ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TRight">右ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TLeftDuration">左ソース シーケンスで各要素の計算された期間を示す期間シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TRightDuration">右ソース シーケンスで各要素の計算された期間を示す期間シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">期間が重複するソース要素の結果選択関数を呼び出すことによって得られる結果シーケンス内の要素のタイプ。</typeparam>
            <param name="left">要素を結合する左の監視可能なシーケンス。</param>
            <param name="right">要素を結合する右の監視可能なシーケンス。</param>
            <param name="leftDurationSelector">左の監視可能なシーケンスの各要素の期間を選択する関数。重複を判定するために使われます。</param>
            <param name="rightDurationSelector">右の監視可能なシーケンスの各要素の期間を選択する関数。重複を判定するために使われます。</param>
            <param name="resultSelector">右の監視可能なシーケンスから重複する要素を持つ左シーケンスの任意の要素の結果要素を計算するために呼び出される関数。</param>
            <returns>期間が重複するソース要素から計算された結果要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> または <paramref name="right"/>、<paramref name="leftDurationSelector"/>、<paramref name="rightDurationSelector"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Join``5(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``2}},System.Func{``1,System.IObservable{``3}},System.Func{``0,``1,``4})">
            <summary>重複する期間に基づいて、2 つのシーケンスの要素を関連付けます。</summary>
            <typeparam name="TLeft">左ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TRight">右ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TLeftDuration">左ソース シーケンスで各要素の計算された期間を示す期間シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TRightDuration">右ソース シーケンスで各要素の計算された期間を示す期間シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">期間が重複するソース要素の結果選択関数を呼び出すことによって得られる結果シーケンス内の要素のタイプ。</typeparam>
            <param name="left">要素を結合する左の監視可能なシーケンス。</param>
            <param name="right">要素を結合する右の監視可能なシーケンス。</param>
            <param name="leftDurationSelector">左の監視可能なシーケンスの各要素の期間を選択する関数。重複を判定するために使われます。</param>
            <param name="rightDurationSelector">右の監視可能なシーケンスの各要素の期間を選択する関数。重複を判定するために使われます。</param>
            <param name="resultSelector">左右の監視可能なシーケンスの 2 つの重複する要素の結果要素を計算するために呼び出される関数。</param>
            <returns>期間が重複するソース要素から計算された結果要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> または <paramref name="right"/>、<paramref name="leftDurationSelector"/>、<paramref name="rightDurationSelector"/>、<paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.OfType``1(System.IObservable{System.Object})">
            <summary>指定されたタイプに基づいて、監視可能なシーケンスの要素をフィルター処理します。</summary>
            <typeparam name="TResult">ソース シーケンス内の要素をフィルター処理するタイプ。</typeparam>
            <param name="source">フィルター処理する要素を含む監視可能なシーケンス。</param>
            <returns>TResult タイプの入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>監視可能なシーケンスの各要素を新しい形式に投入します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">ソース シーケンス内の各要素の選択関数を実行して取得した結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">変換関数を呼び出す要素のシーケンス。</param>
            <param name="selector">各ソース要素に適用する変換関数。</param>
            <returns>ソースの各要素で変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Select``2(System.IObservable{``0},System.Func{``0,System.Int32,``1})">
            <summary>要素のインデックスを組み込むことで、監視可能なシーケンスの各要素を新しい形式に投入します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">ソース シーケンス内の各要素の選択関数を実行して取得した結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">変換関数を呼び出す要素のシーケンス。</param>
            <param name="selector">各ソース要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>ソースの各要素で変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>ソースの監視可能なシーケンスの各要素を他の監視可能なシーケンスに投入し、結果として得られる監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TOther">他のシーケンス内の要素と結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="other">ソース シーケンスから各要素を投入する監視可能なシーケンス。</param>
            <returns>各ソース要素を他のシーケンスに投入し、結果のすべてのシーケンスをマージした結果である監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>監視可能なシーケンスの各要素を監視可能なシーケンスに投入し、結果として得られる監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入された内部シーケンス内の要素と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素に対して 1 対多の変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素を監視可能なシーケンスに投入し、結果として得られる監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入された内部シーケンス内の要素と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素に対して 1 対多の変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>監視可能なシーケンスの各要素をタスクに投入し、すべてのタスク結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入されたタスクによって生成される結果と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素に対して実行されるタスクの結果である要素を持つ監視可能なシーケンス。</returns>
            <remarks>このオーバーロードは、<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用して監視可能なシーケンスにタスクを手動で変換することなく、監視可能なシーケンスとタスクの構成をサポートします。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.Tasks.Task{``1}})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素をタスクに投入し、すべてのタスク結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入されたタスクによって生成される結果と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素に対して実行されるタスクの結果である要素を持つ監視可能なシーケンス。</returns>
            <remarks>このオーバーロードは、<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用して監視可能なシーケンスにタスクを手動で変換することなく、監視可能なシーケンスとタスクの構成をサポートします。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>監視可能なシーケンスの各要素を取り消しサポートのあるタスクに投入し、すべてのタスク結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入されたタスクによって生成される結果と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素に対して実行されるタスクの結果である要素を持つ監視可能なシーケンス。</returns>
            <remarks>このオーバーロードは、<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用して監視可能なシーケンスにタスクを手動で変換することなく、監視可能なシーケンスとタスクの構成をサポートします。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>取り消しサポートを含む要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素をタスクに投入し、すべてのタスク結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入されたタスクによって生成される結果と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素に対して実行されるタスクの結果である要素を持つ監視可能なシーケンス。</returns>
            <remarks>このオーバーロードは、<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用して監視可能なシーケンスにタスクを手動で変換することなく、監視可能なシーケンスとタスクの構成をサポートします。</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.Func{``0,``1,``2})">
            <summary>監視可能なシーケンスの各要素を監視可能なシーケンスに投入し、ソース要素および対応する各内部シーケンスの各要素の結果セレクターを呼び出し、その結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TCollection">投入された中間シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソース シーケンス要素を対応する中間シーケンス要素に組み合わせて取得する、結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="collectionSelector">各要素に適用する変換関数。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素で一対多の変換関数 collectionSelector を呼び出し、それらのシーケンス要素および対応するソース要素を結果要素にマッピングした結果である監視可能なシーケンス要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="collectionSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}},System.Func{``0,System.Int32,``1,System.Int32,``2})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素を監視可能なシーケンスに投入し、ソース要素および対応する各内部シーケンスの各要素の結果セレクターを呼び出して、その結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TCollection">投入された中間シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソース シーケンス要素を対応する中間シーケンス要素に組み合わせて取得する、結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="collectionSelector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。関数の 2 番目のパラメーターはソース要素のインデックスを表し、4 番目のパラメーターは中間要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素で一対多の変換関数 collectionSelector を呼び出し、それらのシーケンス要素および対応するソース要素を結果要素にマッピングした結果である監視可能なシーケンス要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="collectionSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Func{``0,``1,``2})">
            <summary>監視可能なシーケンスの各要素をタスクに投入し、ソース要素とタスク結果の結果セレクターを呼び出して、結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTaskResult">投入された中間タスクによって生成される結果のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソースシーケンス要素を対応する中間タスク結果に組み合わせることによって得られる結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="taskSelector">各要素に適用する変換関数。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素のタスクを取得し、タスクの結果とそれに対応するソース要素を結果要素にマッピングした結果である要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="taskSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>このオーバーロードは、C# と Visual Basic で LINQ クエリ読解構文を使用した監視可能なシーケンスとタスクの構成をサポートします。<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用してタスクを監視可能なシーケンスに手動で変換する必要はありません。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.Tasks.Task{``1}},System.Func{``0,System.Int32,``1,``2})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素をタスクに投入し、ソース要素とタスク結果の結果セレクターを呼び出して、結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTaskResult">投入された中間タスクによって生成される結果のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソースシーケンス要素を対応する中間タスク結果に組み合わせることによって得られる結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="taskSelector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素のタスクを取得し、タスクの結果とそれに対応するソース要素を結果要素にマッピングした結果である要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="taskSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>このオーバーロードは、C# と Visual Basic で LINQ クエリ読解構文を使用した監視可能なシーケンスとタスクの構成をサポートします。<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用してタスクを監視可能なシーケンスに手動で変換する必要はありません。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Func{``0,``1,``2})">
            <summary>監視可能なシーケンスの各要素を、取り消しサポートのあるタスクに投入し、ソース要素とタスク結果の結果セレクターを呼び出して、結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTaskResult">投入された中間タスクによって生成される結果のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソースシーケンス要素を対応する中間タスク結果に組み合わせることによって得られる結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="taskSelector">各要素に適用する変換関数。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素のタスクを取得し、タスクの結果とそれに対応するソース要素を結果要素にマッピングした結果である要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="taskSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>このオーバーロードは、C# と Visual Basic で LINQ クエリ読解構文を使用した監視可能なシーケンスとタスクの構成をサポートします。<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用してタスクを監視可能なシーケンスに手動で変換する必要はありません。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.Func{``0,System.Int32,``1,``2})">
            <summary>取り消しサポートのある要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素をタスクに投入し、ソース要素とタスク結果の結果セレクターを呼び出し、結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTaskResult">投入された中間タスクによって生成される結果のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソースシーケンス要素を対応する中間タスク結果に組み合わせることによって得られる結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="taskSelector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素のタスクを取得し、タスクの結果とそれに対応するソース要素を結果要素にマッピングした結果である要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="taskSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>このオーバーロードは、C# と Visual Basic で LINQ クエリ読解構文を使用した監視可能なシーケンスとタスクの構成をサポートします。<see cref="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})"/> を使用してタスクを監視可能なシーケンスに手動で変換する必要はありません。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.Func{System.Exception,System.IObservable{``1}},System.Func{System.IObservable{``1}})">
            <summary>監視可能なシーケンスの各通知を監視可能なシーケンスに投入し、結果として得られる監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入された内部シーケンス内の要素と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">プロジェクトへの通知の監視可能なシーケンス。</param>
            <param name="onNext">各要素に適用する変換関数。</param>
            <param name="onError">ソース シーケンスでエラーが発生した場合に適用される変換関数。</param>
            <param name="onCompleted">ソース シーケンスの末端に達した場合に適用される変換関数。</param>
            <returns>入力シーケンス内の各通知に対応する一対多の変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> あるいは <paramref name="onError"/> もしくは <paramref name="onCompleted"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.IObservable{``1}},System.Func{System.Exception,System.IObservable{``1}},System.Func{System.IObservable{``1}})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各通知を監視可能なシーケンスに投入し、結果として得られる監視可能なシーケンスを 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入された内部シーケンス内の要素と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">プロジェクトへの通知の監視可能なシーケンス。</param>
            <param name="onNext">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <param name="onError">ソース シーケンスでエラーが発生した場合に適用される変換関数。</param>
            <param name="onCompleted">ソース シーケンスの末端に達した場合に適用される変換関数。</param>
            <returns>入力シーケンス内の各通知に対応する一対多の変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="onNext"/> あるいは <paramref name="onError"/> もしくは <paramref name="onCompleted"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>監視可能なシーケンスの各要素を列挙可能なシーケンスに投入し、結果の列挙可能なシーケンスを 1 つの監視可能なシーケンスに連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入された内側列挙可能シーケンス内の要素と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素に対して 1 対多の変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>投入されたシーケンスは、ソース シーケンスの OnNext 呼び出し内で同期して列挙されます。非ブロッキング同時マージを行うには、セレクターを変更し、<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/> 変換を使用して取得した監視可能なシーケンスを返します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``2(System.IObservable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素を列挙可能なシーケンスに投入し、結果の列挙可能なシーケンスを 1 つの監視可能なシーケンスに連結します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">投入された内側列挙可能シーケンス内の要素と、マージされた結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="selector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素に対して 1 対多の変換関数を呼び出した結果の要素を持つ監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="selector"/> は null です。</exception>
            <remarks>投入されたシーケンスは、ソース シーケンスの OnNext 呼び出し内で同期して列挙されます。非ブロッキング同時マージを行うには、セレクターを変更し、<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/> 変換を使用して取得した監視可能なシーケンスを返します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>監視可能なシーケンスの各要素を列挙可能なシーケンスに投入し、ソース要素および対応する内部シーケンスの各要素の結果セレクターを呼び出し、その結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TCollection">投入された中間列挙可能シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソース シーケンス要素を対応する中間シーケンス要素に組み合わせて取得する、結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="collectionSelector">各要素に適用する変換関数。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。</param>
            <returns>入力シーケンスの各要素で一対多の変換関数 collectionSelector を呼び出し、それらのシーケンス要素および対応するソース要素を結果要素にマッピングした結果である監視可能なシーケンス要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="collectionSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>投入されたシーケンスは、ソース シーケンスの OnNext 呼び出し内で同期して列挙されます。非ブロッキング同時マージを行うには、セレクターを変更し、<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/> 変換を使用して取得した監視可能なシーケンスを返します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SelectMany``3(System.IObservable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,System.Int32,``1,System.Int32,``2})">
            <summary>要素のインデックスを組み込むことによって、監視可能なシーケンスの各要素を列挙可能なシーケンスに投入し、ソース要素および対応する内部シーケンスの各要素の結果セレクターを呼び出し、その結果を 1 つの監視可能なシーケンスにマージします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TCollection">投入された中間列挙可能シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">セレクターを使用してソース シーケンス要素を対応する中間シーケンス要素に組み合わせて取得する、結果シーケンス内の要素のタイプ。</typeparam>
            <param name="source">投入する要素の監視可能なシーケンス。</param>
            <param name="collectionSelector">各要素に適用する変換関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <param name="resultSelector">中間シーケンスの各要素に適用する変換関数。関数の 2 番目のパラメーターはソース要素のインデックスを表し、4 番目のパラメーターは中間要素のインデックスを表します。</param>
            <returns>入力シーケンスの各要素で一対多の変換関数 collectionSelector を呼び出し、それらのシーケンス要素および対応するソース要素を結果要素にマッピングした結果である監視可能なシーケンス要素。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="collectionSelector"/> あるいは <paramref name="resultSelector"/> は null です。</exception>
            <remarks>投入されたシーケンスは、ソース シーケンスの OnNext 呼び出し内で同期して列挙されます。非ブロッキング同時マージを行うには、セレクターを変更し、<see cref="M:System.Reactive.Linq.Observable.ToObservable``1(System.Collections.Generic.IEnumerable{``0})"/> 変換を使用して取得した監視可能なシーケンスを返します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンス内の指定された数の要素をバイパスし、残りの要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むシーケンス。</param>
            <param name="count">残りの要素を返す前にスキップする要素の数。</param>
            <returns>入力シーケンスで指定されたインデックスの後に発生する要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>指定された条件が true である限り、監視可能なシーケンス内の要素をバイパスし、残りの要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を返す監視可能なシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。</param>
            <returns>述語で指定されたテストに合格しない線形系列の最初の要素から始まる入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipWhile``1(System.IObservable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>指定された条件が true である限り、監視可能なシーケンス内の要素をバイパスし、残りの要素を返します。要素のインデックスは、述語関数のロジックで使用されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を返す監視可能なシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>述語で指定されたテストに合格しない線形系列の最初の要素から始まる入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32)">
            <summary>監視可能なシーケンスの先頭から指定された数の連続する要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むシーケンス。</param>
            <param name="count">返す要素の数。</param>
            <returns>入力シーケンスの先頭から指定された数の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>Take(0) のエッジ ケース向けに指定された Scheduler を使用して、監視可能なシーケンスの先頭から指定された数の連続する要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むシーケンス。</param>
            <param name="count">返す要素の数。</param>
            <param name="scheduler"><paramref name="count">カウント </paramref> が 0 に設定されている場合に OnCompleted メッセージを生成するために使用される Scheduler。</param>
            <returns>入力シーケンスの先頭から指定された数の要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeWhile``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>指定された条件が true である限り、監視可能なシーケンスから要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を返すシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。</param>
            <returns>テストに合格しなくなった要素の前に発生する入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeWhile``1(System.IObservable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>指定された条件が true である限り、監視可能なシーケンスから要素を返します。要素のインデックスは、述語関数のロジックで使用されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を返すシーケンス。</param>
            <param name="predicate">条件の各要素をテストする関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>テストに合格しなくなった要素の前に発生する入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>述語に基づいて監視可能なシーケンスの要素をフィルター処理します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">フィルター処理する要素を持つ監視可能なシーケンス。</param>
            <param name="predicate">条件の各ソース要素をテストする関数。</param>
            <returns>条件を満たす入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Where``1(System.IObservable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>要素のインデックスを組み込むことによって、述語に基づいて監視可能なシーケンスの要素をフィルター処理します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">フィルター処理する要素を持つ監視可能なシーケンス。</param>
            <param name="predicate">条件の各ソース要素をテストする関数。関数の 2 番目のパラメーターは、ソース要素のインデックスを表します。</param>
            <returns>条件を満たす入力シーケンスの要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="predicate"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なシーケンスの各要素を、タイミング情報に基づいて生成される重複しない連続バッファーに投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="timeSpan">各バッファーの長さ。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="timeSpan"/> で TimeSpan.Zero 値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くバッファーを作成できます。すべてのソース シーケンス要素はバッファーの 1 つに含まれるため、一部のバッファーの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限でも、現在のバッファーを閉じて新しいバッファーを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>タイミング情報に基づいて生成される重複しない連続バッファーに監視可能なシーケンスの各要素を投入し、指定された Scheduler を使用してタイマーを実行します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="timeSpan">各バッファーの長さ。</param>
            <param name="scheduler">バッファーリング タイマーを実行する Scheduler。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="timeSpan"/> で TimeSpan.Zero 値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くバッファーを作成できます。すべてのソース シーケンス要素はバッファーの 1 つに含まれるため、一部のバッファーの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限でも、現在のバッファーを閉じて新しいバッファーを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan)">
            <summary>タイミング情報に基づいて生成される 0 個以上のバッファーに監視可能なシーケンスの各要素を投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="timeSpan">各バッファーの長さ。</param>
            <param name="timeShift">連続するバッファーの作成間隔。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> または <paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler は最小期間のバッファーを作成します。ただし、一部のバッファーにはゼロの期間はありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在のバッファーを閉じるアクションがすぐに実行されない可能性があります。</para>
            <para><paramref name="timeShift"/> で TimeSpan.Zero 値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くバッファーを作成できます。ただし、これは、すべてのバッファーがソース シーケンスの先頭から開始されることを意味するわけではありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、新しいバッファーを作成するアクションがすぐに実行されない場合があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>タイミング情報に基づいて生成される 0 個以上のバッファーに監視可能なシーケンスの各要素を投入し、指定された Scheduler を使用してタイマーを実行します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="timeSpan">各バッファーの長さ。</param>
            <param name="timeShift">連続するバッファーの作成間隔。</param>
            <param name="scheduler">バッファーリング タイマーを実行する Scheduler。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> または <paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler は最小期間のバッファーを作成します。ただし、一部のバッファーにはゼロの期間はありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在のバッファーを閉じるアクションがすぐに実行されない可能性があります。</para>
            <para><paramref name="timeShift"/> で TimeSpan.Zero 値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くバッファーを作成できます。ただし、これは、すべてのバッファーがソース シーケンスの先頭から開始されることを意味するわけではありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、新しいバッファーを作成するアクションがすぐに実行されない場合があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.Int32)">
            <summary>いっぱいになるか、一定の時間が経過した際に送信されるバッファーに、監視可能なシーケンスの各要素を投入します。このオーバーロードを現実世界にたとえるなら、満席になった場合、または出港予定時間のいずれか早い方にドックを出るフェリーです。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="timeSpan">ウィンドウの最大時間。</param>
            <param name="count">ウィンドウの最大要素数。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。-または- <paramref name="count"/> は 0 以下です。</exception>
            <remarks><paramref name="timeSpan"/> で TimeSpan.Zero 値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くバッファーを作成できます。すべてのソース シーケンス要素はバッファーの 1 つに含まれるため、一部のバッファーの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限でも、現在のバッファーを閉じて新しいバッファーを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Buffer``1(System.IObservable{``0},System.TimeSpan,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、いっぱいになった場合または特定の時間が経過した際に送信されるバッファーに監視可能なシーケンスの各要素を投入します。このオーバーロードを現実世界にたとえるなら、満席になった場合、または出港予定時間のいずれか早い方にドックを出るフェリーです。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのリスト内の要素のタイプ。</typeparam>
            <param name="source">バッファーを生成するソース シーケンス。</param>
            <param name="timeSpan">バッファーの最大時間。</param>
            <param name="count">バッファーの最大要素数。</param>
            <param name="scheduler">バッファーリング タイマーを実行する Scheduler。</param>
            <returns>バッファーの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。-または- <paramref name="count"/> は 0 以下です。</exception>
            <remarks><paramref name="timeSpan"/> で TimeSpan.Zero 値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くバッファーを作成できます。すべてのソース シーケンス要素はバッファーの 1 つに含まれるため、一部のバッファーの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限でも、現在のバッファーを閉じて新しいバッファーを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan)">
            <summary>時間は、指定された相対期間によって監視可能なシーケンスをシフトします。値の間の相対時間間隔は保持されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を遅延させるソース シーケンス。</param>
            <param name="dueTime">監視可能なシーケンスをシフトする相対時間。この値が TimeSpan.Zero に等しい場合、Scheduler はできるだけ早くオブザーバー コールバックをディスパッチします。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>この演算子は、 あらゆる通知と遅延を記録するため、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)">DelaySubscription</see> よりも効率が悪くなります。このため、エラーの即時伝達が可能になります。</para>
            <para>結果のシーケンスのオブザーバー コールバックは、既定の Scheduler で実行されます。この効果は、ObserveOn を使用した場合と似ています。</para>
            <para>OnError コールバックを介してソース シーケンスによって通知された例外は、すぐに結果シーケンスに転送されます。OnError コールバックのポイントでキューに入っていた OnNext 通知は削除されます。エラーの伝達を遅らせるには、<see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> と <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 演算子を使用するか、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)">DelaySubscription</see> を使用することを検討してください。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>時間は、指定された Scheduler を使用してタイマーを実行し、指定された相対期間によって監視可能なシーケンスをシフトします。値の間の相対時間間隔は保持されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を遅延させるソース シーケンス。</param>
            <param name="dueTime">監視可能なシーケンスをシフトする相対時間。この値が TimeSpan.Zero に等しい場合、Scheduler はできるだけ早くオブザーバー コールバックをディスパッチします。</param>
            <param name="scheduler">遅延タイマーを実行する Scheduler。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>この演算子は、 あらゆる通知と遅延を記録するため、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see> よりも効率が悪くなります。このため、エラーの即時伝達が可能になります。</para>
            <para>結果のシーケンスのオブザーバー コールバックは、指定された Scheduler で実行されます。この効果は、ObserveOn を使用した場合と似ています。</para>
            <para>OnError コールバックを介してソース シーケンスによって通知された例外は、すぐに結果シーケンスに転送されます。OnError コールバックのポイントでキューに入っていた OnNext 通知は削除されます。</para>
            <para>OnError コールバックを介してソース シーケンスによって通知された例外は、すぐに結果シーケンスに転送されます。OnError コールバックのポイントでキューに入っていた OnNext 通知は削除されます。エラーの伝達を遅らせるには、<see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> と <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 演算子を使用するか、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see> を使用することを検討してください。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>時間は、指定された絶対時刻に通知の伝達を開始するために監視可能なシーケンスをシフトします。値の間の相対時間間隔は保持されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を遅延させるソース シーケンス。</param>
            <param name="dueTime">監視可能なシーケンスをシフトするために使用される絶対時間。相対的な時間のシフトはサブスクリプション後に計算されます。この値が DateTimeOffset.UtcNow 以下の場合、Scheduler はできるだけ早くオブザーバー コールバックをディスパッチします。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>
            <para>この演算子は、 あらゆる通知と遅延を記録するため、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset)">DelaySubscription</see> よりも効率が悪くなります。このため、エラーの即時伝達が可能になります。</para>
            <para>結果のシーケンスのオブザーバー コールバックは、既定の Scheduler で実行されます。この効果は、ObserveOn を使用した場合と似ています。</para>
            <para>OnError コールバックを介してソース シーケンスによって通知された例外は、すぐに結果シーケンスに転送されます。OnError コールバックのポイントでキューに入っていた OnNext 通知は削除されます。エラーの伝達を遅らせるには、<see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> と <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 演算子を使用するか、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset)">DelaySubscription</see> を使用することを検討してください。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>Time は、指定された Scheduler を使用してタイマーを実行し、指定された絶対時刻に通知の伝達を開始するために監視可能なシーケンスをシフトします。値の間の相対時間間隔は保持されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を遅延させるソース シーケンス。</param>
            <param name="dueTime">監視可能なシーケンスをシフトするために使用される絶対時間。相対的な時間のシフトはサブスクリプション後に計算されます。この値が DateTimeOffset.UtcNow 以下の場合、Scheduler はできるだけ早くオブザーバー コールバックをディスパッチします。</param>
            <param name="scheduler">遅延タイマーを実行する Scheduler。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>この演算子は、 あらゆる通知と遅延を記録するため、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see> よりも効率が悪くなります。このため、エラーの即時伝達が可能になります。</para>
            <para>結果のシーケンスのオブザーバー コールバックは、指定された Scheduler で実行されます。この効果は、ObserveOn を使用した場合と似ています。</para>
            <para>OnError コールバックを介してソース シーケンスによって通知された例外は、すぐに結果シーケンスに転送されます。OnError コールバックのポイントでキューに入っていた OnNext 通知は削除されます。エラーの伝達を遅らせるには、<see cref="M:System.Reactive.Linq.Observable.Materialize``1(System.IObservable{``0})">Observable.Materialize</see> と <see cref="M:System.Reactive.Linq.Observable.Dematerialize``1(System.IObservable{System.Reactive.Notification{``0}})">Observable.Dematerialize</see> 演算子を使用するか、<see cref="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">DelaySubscription</see> を使用することを検討してください。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>Time は、各要素の遅延選択関数に基づいて監視可能なシーケンスをシフトします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TDelay">ソース シーケンス内の各要素の遅延期間を示すために使用される遅延シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を遅延させるソース シーケンス。</param>
            <param name="delayDurationSelector">特定の各要素の遅延を示すシーケンスを取得する選択関数。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="delayDurationSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Delay``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})">
            <summary>Time は、各要素のサブスクリプション遅延と遅延選択関数に基づいて、監視可能なシーケンスをシフトします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TDelay">ソース シーケンス内の各要素の遅延期間を示すために使用される遅延シーケンス内の要素のタイプ。</typeparam>
            <param name="source">値を遅延させるソース シーケンス。</param>
            <param name="subscriptionDelay">ソースへのサブスクリプションの遅延を示すシーケンス。</param>
            <param name="delayDurationSelector">特定の各要素の遅延を示すシーケンスを取得する選択関数。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="subscriptionDelay"/> あるいは <paramref name="delayDurationSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Time は、指定された相対期間でサブスクリプションを遅延することによって、監視可能なシーケンスをシフトします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サブスクリプションを遅延させるソース シーケンス。</param>
            <param name="dueTime">サブスクリプションの相対時間シフト。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>この演算子は <see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan)">Delay</see> よりも効率的ですが、サブスクリプションのすべての副作用を延期し、エラー伝達のタイミングに影響します。 </para>
            <para>ソース シーケンスのサブスクライブの副作用は、既定の Scheduler で実行されます。オブザーバー コールバックは影響を受けません。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>Time は、指定された Scheduler を使用してタイマーを実行し、指定された相対期間でサブスクリプションを遅延させることで監視可能なシーケンスをシフトします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サブスクリプションを遅延させるソース シーケンス。</param>
            <param name="dueTime">サブスクリプションの相対時間シフト。</param>
            <param name="scheduler">サブスクリプション遅延タイマーを実行する Scheduler。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>この演算子は <see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">Delay</see> よりも効率的ですが、サブスクリプションのすべての副作用を延期し、エラー伝達のタイミングに影響します。</para>
            <para>ソース シーケンスのサブスクライブの副作用は、指定された Scheduler で実行されます。オブザーバー コールバックは影響を受けません。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>Time は、サブスクリプションを指定された絶対時間に遅らせることによって、監視可能なシーケンスをシフトします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サブスクリプションを遅延させるソース シーケンス。</param>
            <param name="dueTime">サブスクリプションを実行する絶対時間。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>
            <para>この演算子は <see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset)">Delay</see> よりも効率的ですが、サブスクリプションのすべての副作用を延期し、エラー伝達のタイミングに影響します。</para>
            <para>ソース シーケンスのサブスクライブの副作用は、既定の Scheduler で実行されます。オブザーバー コールバックは影響を受けません。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.DelaySubscription``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>Time は、指定された Scheduler を使用してタイマーを実行し、サブスクリプションを指定した絶対時間に遅延することによって、監視可能なシーケンスをシフトします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サブスクリプションを遅延させるソース シーケンス。</param>
            <param name="dueTime">サブスクリプションを実行する絶対時間。</param>
            <param name="scheduler">サブスクリプション遅延タイマーを実行する Scheduler。</param>
            <returns>時間シフト シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>
            <para>この演算子は <see cref="M:System.Reactive.Linq.Observable.Delay``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">Delay</see> よりも効率的ですが、サブスクリプションのすべての副作用を延期し、エラー伝達のタイミングに影響します。</para>
            <para>ソース シーケンスのサブスクライブの副作用は、指定された Scheduler で実行されます。オブザーバー コールバックは影響を受けません。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan})">
            <summary>シーケンスの要素を生成する状態駆動タイプの一時的ループを実行して、監視可能なシーケンスを生成します。</summary>
            <typeparam name="TState">ジェネレーター ループで使用される状態のタイプ。</typeparam>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="initialState">初期状態。</param>
            <param name="condition">生成を終了する条件 (false を返す場合)。</param>
            <param name="iterate">反復ステップ関数。</param>
            <param name="resultSelector">シーケンスで生成された結果の選択関数。</param>
            <param name="timeSelector">各反復で生成される値の速度を制御する時間選択関数。</param>
            <returns>生成されたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="iterate"/> あるいは <paramref name="resultSelector"/> もしくは <paramref name="timeSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan},System.Reactive.Concurrency.IScheduler)">
            <summary>シーケンスの要素を生成する状態駆動タイプの一時的ループを実行して、監視可能なシーケンスを生成します。指定された Scheduler を使用してタイマーを実行し、オブザーバー メッセージを送信します。</summary>
            <typeparam name="TState">ジェネレーター ループで使用される状態のタイプ。</typeparam>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="initialState">初期状態。</param>
            <param name="condition">生成を終了する条件 (false を返す場合)。</param>
            <param name="iterate">反復ステップ関数。</param>
            <param name="resultSelector">シーケンスで生成された結果の選択関数。</param>
            <param name="timeSelector">各反復で生成される値の速度を制御する時間選択関数。</param>
            <param name="scheduler">ジェネレーター ループを実行する Scheduler。</param>
            <returns>生成されたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="iterate"/>、<paramref name="resultSelector"/>、<paramref name="timeSelector"/>、<paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.DateTimeOffset})">
            <summary>シーケンスの要素を生成する状態駆動タイプの一時的ループを実行して、監視可能なシーケンスを生成します。</summary>
            <typeparam name="TState">ジェネレーター ループで使用される状態のタイプ。</typeparam>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="initialState">初期状態。</param>
            <param name="condition">生成を終了する条件 (false を返す場合)。</param>
            <param name="iterate">反復ステップ関数。</param>
            <param name="resultSelector">シーケンスで生成された結果の選択関数。</param>
            <param name="timeSelector">各反復で生成される値の速度を制御する時間選択関数。</param>
            <returns>生成されたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="iterate"/> あるいは <paramref name="resultSelector"/> もしくは <paramref name="timeSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.DateTimeOffset},System.Reactive.Concurrency.IScheduler)">
            <summary>シーケンスの要素を生成する状態駆動タイプの一時的ループを実行して、監視可能なシーケンスを生成します。指定された Scheduler を使用してタイマーを実行し、オブザーバー メッセージを送信します。</summary>
            <typeparam name="TState">ジェネレーター ループで使用される状態のタイプ。</typeparam>
            <typeparam name="TResult">生成されたシーケンス内の要素のタイプ。</typeparam>
            <param name="initialState">初期状態。</param>
            <param name="condition">生成を終了する条件 (false を返す場合)。</param>
            <param name="iterate">反復ステップ関数。</param>
            <param name="resultSelector">シーケンスで生成された結果の選択関数。</param>
            <param name="timeSelector">各反復で生成される値の速度を制御する時間選択関数。</param>
            <param name="scheduler">ジェネレーター ループを実行する Scheduler。</param>
            <returns>生成されたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition"/> または <paramref name="iterate"/>、<paramref name="resultSelector"/>、<paramref name="timeSelector"/>、<paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Interval(System.TimeSpan)">
            <summary>各期間の後に値を生成する監視可能なシーケンスを返します。</summary>
            <param name="period">結果のシーケンス内の値を生成する期間。この値が TimeSpan.Zero と等しい場合、タイマーはできるだけ速く繰り返されます。</param>
            <returns>各期間の後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>間隔は、前の通知の終了と次の通知の開始の間ではなく、後続の通知の開始の間で測定されます。オブザーバーがメッセージを処理するのに間隔期間より長い時間がかかる場合、後続の通知は、現在の通知が処理された直後に配信されます。連続する通知の終了から開始までの時間を制御する必要がある場合は、代わりに  <see cref="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan})"/> 演算子を使用することを検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Interval(System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、オブザーバー メッセージを送信して、各期間の後に値を生成する監視可能なシーケンスを返します。</summary>
            <param name="period">結果のシーケンス内の値を生成する期間。この値が TimeSpan.Zero と等しい場合、タイマーはできるだけ速く繰り返されます。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>各期間の後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> は TimeSpan.Zero 未満です。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
            <remarks>間隔は、前の通知の終了と次の通知の開始の間ではなく、後続の通知の開始の間で測定されます。オブザーバーがメッセージを処理するのに間隔期間より長い時間がかかる場合、後続の通知は、現在の通知が処理された直後に配信されます。連続する通知の終了から開始までの時間を制御する必要がある場合は、代わりに  <see cref="M:System.Reactive.Linq.Observable.Generate``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``0},System.Func{``0,``1},System.Func{``0,System.TimeSpan},System.Reactive.Concurrency.IScheduler)"/> 演算子を使用することを検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sample``1(System.IObservable{``0},System.TimeSpan)">
            <summary>各間隔で監視可能なシーケンスをサンプルします。サンプリング ティックごとに、最後のサンプリング間隔中にソース シーケンス内の最新の要素 (該当する場合) が結果のシーケンスに送られます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サンプルへのソース シーケンス。</param>
            <param name="interval">サンプリングする間隔。この値が TimeSpan.Zero と等しい場合、Scheduler はストリームを継続的にサンプリングします。</param>
            <returns>サンプリングされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="interval"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="interval"/> 向けに TimeSpan.Zero の値を指定しても、すべてのソース シーケンス要素が必ず保持されるわけではありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、サンプリング アクションがすぐに実行されない可能性があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sample``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してサンプリング タイマーを実行し、各間隔で監視可能なシーケンスをサンプリングします。サンプリング ティックごとに、最後のサンプリング間隔中にソース シーケンス内の最新の要素 (該当する場合) が結果のシーケンスに送られます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サンプルへのソース シーケンス。</param>
            <param name="interval">サンプリングする間隔。この値が TimeSpan.Zero と等しい場合、Scheduler はストリームを継続的にサンプリングします。</param>
            <param name="scheduler">サンプリング タイマーを実行する Scheduler。</param>
            <returns>サンプリングされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="interval"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="interval"/> 向けに TimeSpan.Zero の値を指定しても、すべてのソース シーケンス要素が必ず保持されるわけではありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、サンプリング アクションがすぐに実行されない可能性があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Sample``2(System.IObservable{``0},System.IObservable{``1})">
            <summary>サンプリング ティックを生成するサンプラーの監視可能なシーケンスを使用して、ソースの監視可能なシーケンスをサンプリングします。サンプリング ティックごとに、最後のサンプリング間隔中にソース シーケンス内の最新の要素 (該当する場合) が結果のシーケンスに送られます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSample">サンプリング シーケンス内の要素のタイプ。</typeparam>
            <param name="source">サンプルへのソース シーケンス。</param>
            <param name="sampler">ティック シーケンスのサンプリング。</param>
            <returns>サンプリングされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="sampler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なソース シーケンスの先頭から指定された期間、要素をスキップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素をスキップするソース シーケンス。</param>
            <param name="duration">シーケンスの先頭から要素をスキップする期間。</param>
            <returns>ソース シーケンスの先頭から指定した期間、要素がスキップされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para><paramref name="duration"/> 向けに TimeSpan.Zero の値を指定しても、ソース シーケンスの先頭から要素が削除されないという保証はありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、ソース シーケンスからのコールバックを転送するアクションが直ちに実行されない場合があります。</para>
            <para>ソース シーケンスによって生成されたエラーは、<paramref name="duration"/> の前にエラーが発生した場合でも、常に結果シーケンスに転送されます。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Skip``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、監視可能なソース　シーケンスの先頭から指定された期間の要素をスキップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素をスキップするソース シーケンス。</param>
            <param name="duration">シーケンスの先頭から要素をスキップする期間。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>ソース シーケンスの先頭から指定した期間、要素がスキップされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para><paramref name="duration"/> 向けに TimeSpan.Zero の値を指定しても、ソース シーケンスの先頭から要素が削除されないという保証はありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、ソース シーケンスからのコールバックを転送するアクションが直ちに実行されない場合があります。</para>
            <para>ソース シーケンスによって生成されたエラーは、<paramref name="duration"/> の前にエラーが発生した場合でも、常に結果シーケンスに転送されます。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なソース シーケンスの末尾から指定された期間の要素をスキップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素をスキップするソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素をスキップする期間。</param>
            <returns>ソース シーケンスの末尾から指定された期間に要素がスキップされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>この演算子は、最初の <paramref name="duration"/> ウィンドウで受け取った要素を格納するのに十分な長さのキューを蓄積します。より多くの要素を受け取ると、指定された <paramref name="duration"/> よりも古い要素がキューから取得され、結果シーケンスで生成されます。これにより、<paramref name="duration"/> で要素が遅延します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipLast``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、監視可能なソース シーケンスの末尾から指定された期間、要素をスキップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素をスキップするソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素をスキップする期間。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>ソース シーケンスの末尾から指定された期間に要素がスキップされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>この演算子は、最初の <paramref name="duration"/> ウィンドウで受け取った要素を格納するのに十分な長さのキューを蓄積します。より多くの要素を受け取ると、指定された <paramref name="duration"/> よりも古い要素がキューから取得され、結果シーケンスで生成されます。これにより、<paramref name="duration"/> で要素が遅延します。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipUntil``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>指定された開始時刻まで、監視可能なソース シーケンスから要素をスキップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素をスキップするソース シーケンス。</param>
            <param name="startTime">ソース シーケンスから要素の取り込みを開始する時間。この値が DateTimeOffset.UtcNow 以下の場合、要素はスキップされません。</param>
            <returns>指定された開始時刻まで要素がスキップされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <remarks>ソース シーケンスによって生成されたエラーは、<paramref name="startTime"/> の前にエラーが発生した場合でも、常に結果シーケンスに転送されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.SkipUntil``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、指定された開始時刻まで監視可能なソース シーケンスから要素をスキップします。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素をスキップするソース シーケンス。</param>
            <param name="startTime">ソース シーケンスから要素の取り込みを開始する時間。この値が DateTimeOffset.UtcNow 以下の場合、要素はスキップされません。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>指定された開始時刻まで要素がスキップされた監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <remarks>ソース シーケンスによって生成されたエラーは、<paramref name="startTime"/> の前にエラーが発生した場合でも、常に結果シーケンスに転送されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なソース シーケンスの先頭から指定された期間、要素を取得します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの先頭から要素を取得する期間。</param>
            <returns>ソース シーケンスの先頭から指定された期間に取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="duration"/> 向けに TimeSpan.Zero の値を指定しても、空のシーケンスが返される保証はありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、ソース シーケンスからのコールバックの転送を停止するアクションが直ちに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Take``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、監視可能なソース シーケンスの先頭から指定された期間、要素を取得します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの先頭から要素を取得する期間。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>ソース シーケンスの先頭から指定された期間に取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="duration"/> 向けに TimeSpan.Zero の値を指定しても、空のシーケンスが返される保証はありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、ソース シーケンスからのコールバックの転送を停止するアクションが直ちに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なソース シーケンスの末尾から指定された期間内に要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素を取得する期間。</param>
            <returns>ソース シーケンスの末尾から指定された期間に取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>ソース シーケンスの有効期間中、 <paramref name="duration"/> ウィンドウの要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスでドレインされます。これにより、結果要素が <paramref name="duration"/>で遅延されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Schdeuler を使用してタイマーを実行し、監視可能なソース シーケンスの末尾から指定された期間内に要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素を取得する期間。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>ソース シーケンスの末尾から指定された期間に取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>ソース シーケンスの有効期間中、 <paramref name="duration"/> ウィンドウの要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスでドレインされます。これにより、結果要素が <paramref name="duration"/>で遅延されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLast``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用し、タイマーを実行して収集した要素をドレインし、監視可能なソース シーケンスの末尾から指定された期間内に要素を返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素を取得する期間。</param>
            <param name="timerScheduler">タイマーを実行する Scheduler。</param>
            <param name="loopScheduler">収集された要素を排出する Scheduler。</param>
            <returns>ソース シーケンスの末尾から指定された期間に取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="timerScheduler"/> あるいは <paramref name="loopScheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>ソース シーケンスの有効期間中、 <paramref name="duration"/> ウィンドウの要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスでドレインされます。これにより、結果要素が <paramref name="duration"/>で遅延されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLastBuffer``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なソース シーケンスの末尾から指定された期間内に要素を含むリストを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素を取得する期間。</param>
            <returns>ソース シーケンスの末尾から指定された期間に取得された要素の単一のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>ソース シーケンスの有効期間中、 <paramref name="duration"/> ウィンドウの要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスで生成されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeLastBuffer``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、監視可能なソース シーケンスの末尾から指定された期間内に要素を含むリストを返します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="duration">シーケンスの末尾から要素を取得する期間。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>ソース シーケンスの末尾から指定された期間に取得された要素の単一のリストを含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="duration"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>ソース シーケンスの有効期間中、 <paramref name="duration"/> ウィンドウの要素を格納するのに十分な長さのバッファーを蓄積します。ソース シーケンスが完了すると、このバッファーは結果シーケンスで生成されます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeUntil``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>指定された終了時刻まで、指定された期間の要素を取得します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="endTime">ソース シーケンスからの要素の取得を停止する時間。この値が DateTimeOffset.UtcNow 以下の場合、結果ストリームは直ちに完了します。</param>
            <returns>指定された終了時刻まで取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TakeUntil``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、指定された終了時刻まで指定された期間、要素を受け取ります。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">要素を取り込むソース シーケンス。</param>
            <param name="endTime">ソース シーケンスからの要素の取得を停止する時間。この値が DateTimeOffset.UtcNow 以下の場合、結果ストリームは直ちに完了します。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>指定された終了時刻まで取得された要素を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throttle``1(System.IObservable{``0},System.TimeSpan)">
            <summary>指定された相対期間内に別の要素が続く監視可能なシーケンスからの要素を無視します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">スロットルするソース シーケンス。</param>
            <param name="dueTime">各要素のスロットル期間。</param>
            <returns>スロットルされたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>この演算子は、<paramref name="dueTime"/> で指定された期間、各要素を保持してソース シーケンスをスロットルします。この時間枠内に別の要素が生成されると、要素が削除され、現在の要素に対して新しいタイマーが開始され、このプロセス全体が繰り返されます。要素間のギャップが決して <paramref name="dueTime"/> 以上にならないストリームの場合、結果のストリームは要素を生成しません。確実に要素を定期的に生成しながらストリームの量を減らすため、Observable.Sample 演算子のセットを使用することを検討してください。</para>
            <para><paramref name="dueTime"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、スロットル タイマーはすぐに期限が切れるようスケジュールされます。ただし、すべての要素が結果シーケンスに必ず保持されるわけではありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在の要素を転送するアクションが直ちに実行されない場合があります。このような場合、Scheduler がスロットル アクションを実行する前に、次の要素が届く可能性があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throttle``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してスロットル タイマーを実行し、指定された相対期間内に別の要素が続く監視可能なシーケンスの要素を無視します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">スロットルするソース シーケンス。</param>
            <param name="dueTime">各要素のスロットル期間。</param>
            <param name="scheduler">スロットル タイマーを実行する Scheduler。</param>
            <returns>スロットルされたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>この演算子は、<paramref name="dueTime"/> で指定された期間、各要素を保持してソース シーケンスをスロットルします。この時間枠内に別の要素が生成されると、要素が削除され、現在の要素に対して新しいタイマーが開始され、このプロセス全体が繰り返されます。要素間のギャップが決して <paramref name="dueTime"/> 以上にならないストリームの場合、結果のストリームは要素を生成しません。確実に要素を定期的に生成しながらストリームの量を減らすため、Observable.Sample 演算子のセットを使用することを検討してください。</para>
            <para><paramref name="dueTime"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、スロットル タイマーはすぐに期限が切れるようスケジュールされます。ただし、すべての要素が結果シーケンスに必ず保持されるわけではありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在の要素を転送するアクションが直ちに実行されない場合があります。このような場合、Scheduler がスロットル アクションを実行する前に、次の要素が届く可能性があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Throttle``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>計算されたスロットル期間内に別の値が続く監視可能なシーケンスの要素を無視します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TThrottle">ソース シーケンス内の各要素に対して選択されたスロットル シーケンス内の要素のタイプ。</typeparam>
            <param name="source">スロットルするソース シーケンス。</param>
            <param name="throttleDurationSelector">選択関数は、特定の各要素のスロットル期間を示すシーケンスを取得します。</param>
            <returns>スロットルされたシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="throttleDurationSelector"/> は null です。</exception>
            <remarks>この演算子は、<paramref name="throttleDurationSelector"/> で示される期間の各要素を保持することによってソース シーケンスをスロットルします。この時間枠内に別の要素が生成されると、要素が削除され、現在の要素に対して新しいタイマーが開始され、このプロセス全体が繰り返されます。各要素に <paramref name="throttleDurationSelector"/> を適用して計算された期間が後続要素の発生と重複するストリームの場合、結果のストリームは要素を生成しません。確実に要素を定期的に生成しながらストリームの量を減らすため、Observable.Sample 演算子のセットを使用することを検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TimeInterval``1(System.IObservable{``0})">
            <summary>監視可能なシーケンス内の連続する要素間の時間間隔を記録します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">時間間隔を記録するソース シーケンス。</param>
            <returns>要素に関する時間間隔情報を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.TimeInterval``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用して時間間隔を計算し、監視可能なシーケンス内の連続する要素間の時間間隔を記録します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">時間間隔を記録するソース シーケンス。</param>
            <param name="scheduler">時間間隔の計算に使用される Scheduler。</param>
            <returns>要素に関する時間間隔情報を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan)">
            <summary>監視可能なシーケンス内の各要素にタイムアウト ポリシーを適用します。前の要素から始まる指定されたタイムアウト期間内に次の要素を受け取らなかった場合は、タイムアウト例外がオブザーバーに伝達されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生する前の値間の最大期間。</param>
            <returns>タイムアウトの場合に TimeoutException を持つソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <exception cref="T:System.TimeoutException">(非同期) 前の要素から <paramref name="dueTime"/> 内で要素が生成されない場合。</exception>
            <remarks>
            <para>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</para>
            <para><paramref name="dueTime"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、タイムアウト タイマーはすぐに期限が切れるようスケジュールされます。ただし、最初の要素であっても、タイムアウトが発生するわけではありません。これは Scheduler によって導入される非同期の副作用であり、TimeSpan.Zero の期限に関わらず、タイムアウトを伝達するアクションがすぐに実行されない場合があります。このような場合、Scheduler がタイムアウト アクションを実行する前に、次の要素が届く可能性があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイムアウト タイマーを実行し、監視可能なシーケンス内の各要素にタイムアウト ポリシーを適用します。前の要素から始まる指定されたタイムアウト期間内に次の要素を受け取らなかった場合は、タイムアウト例外がオブザーバーに伝達されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生する前の値間の最大期間。</param>
            <param name="scheduler">タイムアウト タイマーを実行する Scheduler。</param>
            <returns>タイムアウトの場合に TimeoutException を持つソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <exception cref="T:System.TimeoutException">(非同期) 前の要素から <paramref name="dueTime"/> 内で要素が生成されない場合。</exception>
            <remarks>
            <para>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</para>
            <para><paramref name="dueTime"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、タイムアウト タイマーはすぐに期限が切れるようスケジュールされます。ただし、最初の要素であっても、タイムアウトが発生するわけではありません。これは Scheduler によって導入される非同期の副作用であり、TimeSpan.Zero の期限に関わらず、タイムアウトを伝達するアクションがすぐに実行されない場合があります。このような場合、Scheduler がタイムアウト アクションを実行する前に、次の要素が届く可能性があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan,System.IObservable{``0})">
            <summary>監視可能なシーケンス内の各要素にタイムアウト ポリシーを適用します。前の要素から始まる指定されたタイムアウト期間内に次の要素を受け取らなかった場合は、他の監視可能なシーケンスを使用して、その時点から将来のメッセージを生成します。</summary>
            <typeparam name="TSource">ソース シーケンスと、タイムアウト後に使用される他のシーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生する前の値間の最大期間。</param>
            <param name="other">タイムアウトの場合に返すシーケンス。</param>
            <returns>タイムアウトの場合に、他のシーケンスに切り替わるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</para>
            <para><paramref name="dueTime"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、タイムアウト タイマーはすぐに期限が切れるようスケジュールされます。ただし、最初の要素であっても、タイムアウトが発生するわけではありません。これは Scheduler によって導入される非同期の副作用であり、TimeSpan.Zero の期限に関わらず、タイムアウトを伝達するアクションがすぐに実行されない場合があります。このような場合、Scheduler がタイムアウト アクションを実行する前に、次の要素が届く可能性があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.TimeSpan,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイムアウト タイマーを実行し、監視可能なシーケンス内の各要素にタイムアウト ポリシーを適用します。前の要素から始まる指定されたタイムアウト期間内に次の要素を受け取らなかった場合は、他の監視可能なシーケンスを使用して、その時点から将来のメッセージを生成します。</summary>
            <typeparam name="TSource">ソース シーケンスと、タイムアウト後に使用される他のシーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生する前の値間の最大期間。</param>
            <param name="other">タイムアウトの場合に返すシーケンス。</param>
            <param name="scheduler">タイムアウト タイマーを実行する Scheduler。</param>
            <returns>タイムアウトの場合に、他のシーケンスに切り替わるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dueTime"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</para>
            <para><paramref name="dueTime"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、タイムアウト タイマーはすぐに期限が切れるようスケジュールされます。ただし、最初の要素であっても、タイムアウトが発生するわけではありません。これは Scheduler によって導入される非同期の副作用であり、TimeSpan.Zero の期限に関わらず、タイムアウトを伝達するアクションがすぐに実行されない場合があります。このような場合、Scheduler がタイムアウト アクションを実行する前に、次の要素が届く可能性があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset)">
            <summary>絶対時間に基づいて、監視可能なシーケンスにタイムアウト ポリシーを適用します。指定された絶対期限までにシーケンスが終了しない場合は、TimeoutException がオブザーバーに伝達されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生した時刻。この値が DateTimeOffset.UtcNow 以下の場合は、タイムアウトが直ちに発生します。</param>
            <returns>タイムアウトの場合に TimeoutException を持つソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.TimeoutException">(非同期) <paramref name="dueTime"/> 前にシーケンスが終了しなかった場合.</exception>
            <remarks>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイムアウト タイマーを実行し、絶対時間に基づいて監視可能なシーケンスにタイムアウト ポリシーを適用します。指定された絶対期限までにシーケンスが終了しない場合は、TimeoutException がオブザーバーに伝達されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生した時刻。この値が DateTimeOffset.UtcNow 以下の場合は、タイムアウトが直ちに発生します。</param>
            <param name="scheduler">タイムアウト タイマーを実行する Scheduler。</param>
            <returns>タイムアウトの場合に TimeoutException を持つソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.TimeoutException">(非同期) <paramref name="dueTime"/> 前にシーケンスが終了しなかった場合.</exception>
            <remarks>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset,System.IObservable{``0})">
            <summary>絶対時間に基づいて、監視可能なシーケンスにタイムアウト ポリシーを適用します。指定された絶対期限までにシーケンスが終了しない場合は、他の監視可能なシーケンスを使用して、その時点から将来のメッセージを生成します。</summary>
            <typeparam name="TSource">ソース シーケンスと、タイムアウト後に使用される他のシーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生した時刻。この値が DateTimeOffset.UtcNow 以下の場合は、タイムアウトが直ちに発生します。</param>
            <param name="other">タイムアウトの場合に返すシーケンス。</param>
            <returns>タイムアウトの場合に、他のシーケンスに切り替わるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> は null です。</exception>
            <remarks>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``1(System.IObservable{``0},System.DateTimeOffset,System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイムアウト タイマーを実行し、絶対時間に基づいて監視可能なシーケンスにタイムアウト ポリシーを適用します。指定された絶対期限までにシーケンスが終了しない場合は、他の監視可能なシーケンスを使用して、その時点から将来のメッセージを生成します。</summary>
            <typeparam name="TSource">ソース シーケンスと、タイムアウト後に使用される他のシーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="dueTime">タイムアウトが発生した時刻。この値が DateTimeOffset.UtcNow 以下の場合は、タイムアウトが直ちに発生します。</param>
            <param name="other">タイムアウトの場合に返すシーケンス。</param>
            <param name="scheduler">タイムアウト タイマーを実行する Scheduler。</param>
            <returns>タイムアウトの場合に、他のシーケンスに切り替わるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="other"/> あるいは <paramref name="scheduler"/> は null です。</exception>
            <remarks>最初の要素でのみタイムアウトする場合は、ソース シーケンスに適用した <see cref="M:System.Reactive.Linq.Observable.Amb``1(System.IObservable{``0},System.IObservable{``0})"/> 演算子と遅延された <see cref="M:System.Reactive.Linq.Observable.Throw``1(System.Exception)"/> シーケンスを使用することを検討してください。あるいは、Timeout の汎用オーバーロード、<see cref="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})"/> を使用することもできます。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}})">
            <summary>各要素に対して計算されたタイムアウト期間に基づいて、監視可能なシーケンスにタイムアウト ポリシーを適用します。前の要素から始まる計算期間内に次の要素を受け取らなかった場合は、TimeoutException がオブザーバーに伝達されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTimeout">ソース シーケンス内の各要素のタイムアウト期間を示すために使用されるタイムアウト シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="timeoutDurationSelector">現在の要素と次の要素の間のタイムアウトを表す監視可能なシーケンスを取得するセレクター。</param>
            <returns>タイムアウトの場合に TimeoutException を持つソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="timeoutDurationSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.Func{``0,System.IObservable{``1}},System.IObservable{``0})">
            <summary>各要素に対して計算されたタイムアウト期間に基づいて、監視可能なシーケンスにタイムアウト ポリシーを適用します。前の要素から始まる計算期間内に次の要素を受け取らなかった場合は、他の監視可能なシーケンスを使用して、その時点から将来のメッセージを生成します。</summary>
            <typeparam name="TSource">ソース シーケンスと、タイムアウト後に使用される他のシーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTimeout">ソース シーケンス内の各要素のタイムアウト期間を示すために使用されるタイムアウト シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="timeoutDurationSelector">現在の要素と次の要素の間のタイムアウトを表す監視可能なシーケンスを取得するセレクター。</param>
            <param name="other">タイムアウトの場合に返すシーケンス。</param>
            <returns>タイムアウトの場合に、他のシーケンスに切り替わるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="timeoutDurationSelector"/> あるいは <paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}})">
            <summary>最初の要素の最初のタイムアウト期間と、後続の各要素に対して計算されたタイムアウト期間に基づいて、監視可能なシーケンスにタイムアウト ポリシーを適用します。前の要素から始まる計算期間内に次の要素を受け取らなかった場合は、TimeoutException がオブザーバーに伝達されます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTimeout">ソース シーケンス内の各要素のタイムアウト期間を示すために使用されるタイムアウト シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="firstTimeout">最初の要素のタイムアウトを表す監視可能なシーケンス。</param>
            <param name="timeoutDurationSelector">現在の要素と次の要素の間のタイムアウトを表す監視可能なシーケンスを取得するセレクター。</param>
            <returns>タイムアウトの場合に TimeoutException を持つソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="firstTimeout"/> あるいは <paramref name="timeoutDurationSelector"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timeout``2(System.IObservable{``0},System.IObservable{``1},System.Func{``0,System.IObservable{``1}},System.IObservable{``0})">
            <summary>最初の要素の最初のタイムアウト期間と、後続の各要素に対して計算されたタイムアウト期間に基づいて、監視可能なシーケンスにタイムアウト ポリシーを適用します。前の要素から始まる計算期間内に次の要素を受け取らなかった場合は、他の監視可能なシーケンスを使用して、その時点から将来のメッセージを生成します。</summary>
            <typeparam name="TSource">ソース シーケンスと、タイムアウト後に使用される他のシーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TTimeout">ソース シーケンス内の各要素のタイムアウト期間を示すために使用されるタイムアウト シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムアウトを実行するソース シーケンス。</param>
            <param name="firstTimeout">最初の要素のタイムアウトを表す監視可能なシーケンス。</param>
            <param name="timeoutDurationSelector">現在の要素と次の要素の間のタイムアウトを表す監視可能なシーケンスを取得するセレクター。</param>
            <param name="other">タイムアウトの場合に返すシーケンス。</param>
            <returns>タイムアウトの場合に、他のシーケンスに切り替わるソース シーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="firstTimeout"/> あるいは <paramref name="timeoutDurationSelector"/> もしくは <paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan)">
            <summary>指定された相対期限が経過した後に単一の値を生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">値を生成する相対時間。この値が TimeSpan.Zero 以下の場合、タイマーはできるだけ早く起動します。</param>
            <returns>期限が経過した後に値を生成する監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset)">
            <summary>指定された絶対期限に単一の値を生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">値を生成する絶対時間。この値が DateTimeOffset.UtcNow 以下の場合、タイマーはできるだけ早く起動します。</param>
            <returns>期限に値を生成する監視可能なシーケンス。</returns>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.TimeSpan)">
            <summary>指定された初期相対期限が経過した後に値を定期的に生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">最初の値を生成する相対時間。この値が TimeSpan.Zero 以下の場合、タイマーはできるだけ早く起動します。</param>
            <param name="period">後続の値を生成する期間。この値が TimeSpan.Zero と等しい場合、タイマーはできるだけ速く繰り返されます。</param>
            <returns>期日が経過した後、各期間の後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> は TimeSpan.Zero 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset,System.TimeSpan)">
            <summary>指定された初期絶対期限から始まる値を定期的に生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">最初の値を生成する絶対時間。この値が DateTimeOffset.UtcNow 以下の場合、タイマーはできるだけ早く起動します。</param>
            <param name="period">後続の値を生成する期間。この値が TimeSpan.Zero と等しい場合、タイマーはできるだけ速く繰り返されます。</param>
            <returns>期限と各期間の後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> は TimeSpan.Zero 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、指定された相対待時間が経過した後に単一の値を生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">値を生成する相対時間。この値が TimeSpan.Zero 以下の場合、タイマーはできるだけ早く起動します。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>期限が経過した後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、指定された絶対期限に単一の値を生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">値を生成する絶対時間。この値が DateTimeOffset.UtcNow 以下の場合、タイマーはできるだけ早く起動します。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>期限に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.TimeSpan,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、指定された初期相対期限が経過した後に定期的に値を生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">最初の値を生成する相対時間。この値が TimeSpan.Zero 以下の場合、タイマーはできるだけ早く起動します。</param>
            <param name="period">後続の値を生成する期間。この値が TimeSpan.Zero と等しい場合、タイマーはできるだけ速く繰り返されます。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>期限が経過した後および各期間の後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> は TimeSpan.Zero 未満です。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timer(System.DateTimeOffset,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、指定された初期絶対期限から始まる値を定期的に生成する監視可能なシーケンスを返します。</summary>
            <param name="dueTime">最初の値を生成する絶対時間。この値が DateTimeOffset.UtcNow 以下の場合、タイマーはできるだけ早く起動します。</param>
            <param name="period">後続の値を生成する期間。この値が TimeSpan.Zero と等しい場合、タイマーはできるだけ速く繰り返されます。</param>
            <param name="scheduler">タイマーを実行する Scheduler。</param>
            <returns>期限と各期間の後に値を生成する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="period"/> は TimeSpan.Zero 未満です。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timestamp``1(System.IObservable{``0})">
            <summary>ローカル システム クロックを使用して、監視可能なシーケンス内の各要素にタイムスタンプを付けます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムスタンプ要素へのソース シーケンス。</param>
            <returns>要素に関するタイムスタンプ情報を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Timestamp``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler のクロックを使用して、監視可能なシーケンス内の各要素にタイムスタンプを付けます。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="source">タイムスタンプ要素へのソース シーケンス。</param>
            <param name="scheduler">タイムスタンプの計算に使用される Scheduler。</param>
            <returns>要素に関するタイムスタンプ情報を含む監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan)">
            <summary>タイミング情報に基づいて生成される連続した重複しないウィンドウに監視可能なシーケンスの各要素を投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="timeSpan">各ウィンドウの長さ。</param>
            <returns>ウィンドウのシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くウィンドウを作成します。すべてのソース シーケンス要素はウィンドウの 1 つに含まれるため、一部のウィンドウの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在のウィンドウを閉じて新しいウィンドウを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、タイミング情報に基づいて生成される重複しない連続したウィンドウに監視可能なシーケンスの各要素を投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="timeSpan">各ウィンドウの長さ。</param>
            <param name="scheduler">ウィンドウ タイマーを実行する Scheduler。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くウィンドウを作成します。すべてのソース シーケンス要素はウィンドウの 1 つに含まれるため、一部のウィンドウの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在のウィンドウを閉じて新しいウィンドウを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan)">
            <summary>タイミング情報に基づいて生成されるゼロ以上のウィンドウに監視可能なシーケンスの各要素を投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="timeSpan">各ウィンドウの長さ。</param>
            <param name="timeShift">連続するウィンドウの作成間隔。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> または <paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler は最小期間のウィンドウを作成します。ただし、一部のウィンドウにはゼロの期間がありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限の期限に関わらず、現在のウィンドウを閉じるアクションがすぐに実行されない場合があります。</para>
            <para><paramref name="timeShift"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くウィンドウを作成します。ただし、これは、すべてのウィンドウがソース シーケンスの先頭で開始されることを意味しません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、新しいウィンドウを作成するアクションがすぐに実行されない場合があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、タイミング情報に基づいて生成される 0 個以上のウィンドウに監視可能なシーケンスの各要素を投入します。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="timeSpan">各ウィンドウの長さ。</param>
            <param name="timeShift">連続するウィンドウの作成間隔。</param>
            <param name="scheduler">ウィンドウ タイマーを実行する Scheduler。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> または <paramref name="timeSpan"/> は TimeSpan.Zero 未満です。</exception>
            <remarks>
            <para><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler は最小期間のウィンドウを作成します。ただし、一部のウィンドウにはゼロの期間がありません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限の期限に関わらず、現在のウィンドウを閉じるアクションがすぐに実行されない場合があります。</para>
            <para><paramref name="timeShift"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くウィンドウを作成します。ただし、これは、すべてのウィンドウがソース シーケンスの先頭で開始されることを意味しません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、新しいウィンドウを作成するアクションがすぐに実行されない場合があります。</para>
            </remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.Int32)">
            <summary>満杯になるか、特定の時間が経過したときに完了するウィンドウに監視可能なシーケンスの各要素を投入します。このオーバーロードを現実世界にたとえるなら、満席になった場合、または出港予定時間のいずれか早い方にドックを出るフェリーです。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="timeSpan">ウィンドウの最大時間。</param>
            <param name="count">ウィンドウの最大要素数。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。-または- <paramref name="count"/> は 0 以下です。</exception>
            <remarks><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くウィンドウを作成します。すべてのソース シーケンス要素はウィンドウの 1 つに含まれるため、一部のウィンドウの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在のウィンドウを閉じて新しいウィンドウを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="M:System.Reactive.Linq.Observable.Window``1(System.IObservable{``0},System.TimeSpan,System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler を使用してタイマーを実行し、満杯になるか、特定の時間が経過したときに完了するウィンドウに監視可能なシーケンスの各要素を投入します。このオーバーロードを現実世界にたとえるなら、満席になった場合、または出港予定時間のいずれか早い方にドックを出るフェリーです。</summary>
            <typeparam name="TSource">ソース シーケンス、および結果シーケンスのウィンドウ内の要素のタイプ。</typeparam>
            <param name="source">ウィンドウを生成するソース シーケンス。</param>
            <param name="timeSpan">ウィンドウの最大時間。</param>
            <param name="count">ウィンドウの最大要素数。</param>
            <param name="scheduler">ウィンドウ タイマーを実行する Scheduler。</param>
            <returns>ウィンドウの監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> は TimeSpan.Zero 未満です。-または- <paramref name="count"/> は 0 以下です。</exception>
            <remarks><paramref name="timeSpan"/> 向けに TimeSpan.Zero の値を指定することはお勧めしませんが、これはサポートされているため、Scheduler はできるだけ速くウィンドウを作成します。すべてのソース シーケンス要素はウィンドウの 1 つに含まれるため、一部のウィンドウの期間は 0 にはなりません。これは Scheduler によって導入された非同期の副作用であり、TimeSpan.Zero の期限に関わらず、現在のウィンドウを閉じて新しいウィンドウを作成するアクションがすぐに実行されない場合があります。</remarks>
        </member>
        <member name="T:System.Reactive.Linq.IQueryLanguage">
            <summary>LINQ to Events クエリ言語を記述する内部インターフェイス。</summary>
        </member>
        <member name="T:System.Reactive.EventPatternSourceBase`2">
            <summary>監視可能なシーケンスを既知のイベント パターン (センダー、イベント引数) として公開するクラスの基本クラス。監視可能なシーケンスのサブスクリプションに対するイベント ハンドラー デリゲートのマップを維持する機能が含まれています。サブクラスでは、基本クラスの操作を呼び出すカスタム add メソッドと remove メソッドを含むイベントのみを追加する必要があります。</summary>
            <typeparam name="TSender">イベントを発生させるセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.EventPatternSourceBase`2.#ctor(System.IObservable{System.Reactive.EventPattern{`0,`1}},System.Action{System.Action{`0,`1},System.Reactive.EventPattern{`0,`1}})">
            <summary>新しいイベント パターン ソースを作成します。</summary>
            <param name="source">イベントとして公開するソース シーケンス。</param>
            <param name="invokeHandler">シーケンスの各要素のイベントを呼び出すために使用されるデリゲート。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> または <paramref name="invokeHandler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.EventPatternSourceBase`2.Add(System.Delegate,System.Action{`0,`1})">
            <summary>指定されたイベント ハンドラーを追加し、基になるソースにサブスクリプションを作成します。</summary>
            <param name="handler">追加するイベント ハンドラー。イベント ハンドラーを削除するには、同じデリゲートを Remove 操作に渡す必要があります。</param>
            <param name="invoke">派生クラスでイベントを発生させる呼び出しデリゲート。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="handler"/> または <paramref name="invoke"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.EventPatternSourceBase`2.Remove(System.Delegate)">
            <summary>指定されたイベント ハンドラーを削除し、Add 操作中に作成された基になるソースに対応するサブスクリプションを破棄します。</summary>
            <param name="handler">削除するイベント ハンドラー。これは、Add 操作に渡されたものと同じデリゲートでなくてはなりません。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="handler"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.EventPattern`1">
            <summary>イベントを発生させた弱い型指定のオブジェクトと、イベントによって生成されたデータで構成される .NET イベント呼び出しを表します。</summary>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
        </member>
        <member name="T:System.Reactive.EventPattern`2">
            <summary>イベントを発生させた厳密に型指定されたオブジェクトと、イベントによって生成されたデータで構成される .NET イベント呼び出しを表します。</summary>
            <typeparam name="TSender">イベントを発生させたセンダーのタイプ。</typeparam>
            <typeparam name="TEventArgs">イベントによって生成されるイベント データのタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.EventPattern`2.#ctor(`0,`1)">
            <summary>特定のセンダーとイベント データを使用して、.NET イベント呼び出しの新しいデータ表現インスタンスを作成します。</summary>
            <param name="sender">イベントを発生させたセンダー オブジェクト。</param>
            <param name="e">イベントによって生成されたイベント データ。</param>
        </member>
        <member name="M:System.Reactive.EventPattern`2.Equals(System.Reactive.EventPattern{`0,`1})">
            <summary>現在の EventPattern&lt;TSender, TEventArgs&gt; オブジェクトが、指定された EventPattern&lt;TSender, TEventArgs&gt; オブジェクトと同じイベントを表すかどうかを判定します。</summary>
            <param name="other">現在の EventPattern&lt;TSender, TEventArgs&gt; オブジェクトと比較するオブジェクト。</param>
            <returns>EventPattern&lt;TSender, TEventArgs&gt; オブジェクトが両方とも同じイベントを表す場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.Equals(System.Object)">
            <summary>指定された System.Object が現在の EventPattern&lt;TSender, TEventArgs&gt; と等しいかどうかを判定します。</summary>
            <param name="obj">現在の EventPattern&lt;TSender, TEventArgs&gt; と比較する System.Object。</param>
            <returns>指定された System.Object が現在の EventPattern&lt;TSender, TEventArgs&gt; と等しい場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.GetHashCode">
            <summary>現在の EventPattern&lt;TSender, TEventArgs&gt; インスタンスのハッシュ コードを返します。</summary>
            <returns>現在の EventPattern&lt;TSender, TEventArgs&gt; インスタンスのハッシュ コード。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.op_Equality(System.Reactive.EventPattern{`0,`1},System.Reactive.EventPattern{`0,`1})">
            <summary>指定された 2 つの EventPattern&lt;TSender, TEventArgs&gt; オブジェクトが同じイベントを表しているかどうかを判定します。</summary>
            <param name="first">比較する最初の EventPattern&lt;TSender, TEventArgs&gt; または null。</param>
            <param name="second">比較する 2 番目の EventPattern&lt;TSender, TEventArgs&gt; または null。</param>
            <returns>EventPattern&lt;TSender, TEventArgs&gt; オブジェクトが両方とも同じイベントを表す場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.EventPattern`2.op_Inequality(System.Reactive.EventPattern{`0,`1},System.Reactive.EventPattern{`0,`1})">
            <summary>指定された 2 つの EventPattern&lt;TSender, TEventArgs&gt; オブジェクトが別のイベントを表しているかどうかを判定します。</summary>
            <param name="first">比較する最初の EventPattern&lt;TSender, TEventArgs&gt; または null。</param>
            <param name="second">比較する 2 番目の EventPattern&lt;TSender, TEventArgs&gt; または null。</param>
            <returns>EventPattern&lt;TSender, TEventArgs&gt; オブジェクトが両方とも同じイベントを表していない場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="P:System.Reactive.EventPattern`2.Sender">
            <summary>イベントを発生させたセンダー オブジェクトを取得します。</summary>
        </member>
        <member name="P:System.Reactive.EventPattern`2.EventArgs">
            <summary>イベントによって生成されたイベント データを取得します。</summary>
        </member>
        <member name="M:System.Reactive.EventPattern`1.#ctor(System.Object,`0)">
            <summary>特定のセンダーとイベント データを使用して、.NET イベント呼び出しの新しいデータ表現インスタンスを作成します。</summary>
            <param name="sender">イベントを発生させたセンダー オブジェクト。</param>
            <param name="e">イベントによって生成されたイベント データ。</param>
        </member>
        <member name="T:System.Reactive.Concurrency.HistoricalSchedulerBase">
            <summary>履歴 Scheduler の基本クラス。絶対時間では DateTimeOffset、絶対時間では TimeSpan を使用する仮想時間 Scheduler です。</summary>
        </member>
        <member name="T:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2">
            <summary>仮想時間 Scheduler の基本クラス。</summary>
            <typeparam name="TAbsolute">絶対時間表現タイプ。</typeparam>
            <typeparam name="TRelative">相対時間表現タイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.#ctor">
            <summary>初期クロック値として TAbsolute の既定値を持つ新しい仮想時間 Scheduler を作成します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.#ctor(`0,System.Collections.Generic.IComparer{`0})">
            <summary>指定した初期クロック値と絶対時間比較関数を持つ新しい仮想時間 Scheduler を作成します。</summary>
            <param name="initialClock">クロックの初期値。</param>
            <param name="comparer">絶対時間に基づいてイベントの因果関係を判定する比較関数。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Add(`0,`1)">
            <summary>相対時間値を絶対時間値に追加します。</summary>
            <param name="absolute">絶対時間値。</param>
            <param name="relative">追加する相対時間値。</param>
            <returns>結果の絶対時間合計値。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ToDateTimeOffset(`0)">
            <summary>絶対時間値を DateTimeOffset 値に変換します。</summary>
            <param name="absolute">変換する絶対時間値。</param>
            <returns>対応する DateTimeOffset 値。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ToRelative(System.TimeSpan)">
            <summary>TimeSpan 値を相対時間値に変換します。</summary>
            <param name="timeSpan">変換する TimeSpan 値。</param>
            <returns>対応する相対時間値。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ScheduleAbsolute``1(``0,`0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="dueTime">アクションを実行する絶対時間。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.ScheduleRelative``1(``0,`1,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="dueTime">その後にアクションを実行する相対時間。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Schedule``1(``0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>実行するアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Schedule``1(``0,System.TimeSpan,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>dueTime 後に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="dueTime">その後にアクションを実行する相対時間。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Schedule``1(``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="dueTime">アクションを実行する絶対時間。</param>
            <param name="action">実行するアクション。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Start">
            <summary>仮想時間 Scheduler を開始します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Stop">
            <summary>仮想時間 Scheduler を停止します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.AdvanceTo(`0)">
            <summary>Scheduler のクロックを指定した時刻に進め、その時点まですべての作業を実行します。</summary>
            <param name="time">Scheduler のクロックを進める絶対時間。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="time"/> は過去です。</exception>
            <exception cref="T:System.InvalidOperationException">Scheduler は既に実行中です。VirtualTimeScheduler は、ネストされた作業ディスパッチ ループの実行をサポートしていません。Scheduler で作業を実行している間の時間の遅延をシミュレートするには、 <see cref="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Sleep(`1)"/>を使用します。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.AdvanceBy(`1)">
            <summary>Scheduler のクロックを指定した相対時間まで進め、その期間にスケジュールされたすべての作業を実行します。</summary>
            <param name="time">Scheduler のクロックを進める相対時間。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="time"/> は負です。</exception>
            <exception cref="T:System.InvalidOperationException">Scheduler は既に実行中です。VirtualTimeScheduler は、ネストされた作業ディスパッチ ループの実行をサポートしていません。Scheduler で作業を実行している間の時間の遅延をシミュレートするには、 <see cref="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Sleep(`1)"/>を使用します。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Sleep(`1)">
            <summary>指定した相対時間で Scheduler のクロックを進めます。</summary>
            <param name="time">Scheduler のクロックを進める相対時間。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="time"/> は負です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.GetNext">
            <summary>実行される次のスケジュールされた項目を取得します。</summary>
            <returns>次のスケジュールされた項目。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.GetService(System.Type)">
            <summary>インターフェイスのタイプで Scheduler のサービスを検出します。基本クラスの実装では、IStopwatchProvider サービスのみをサポートします。他の Scheduler サービスのサポートの追加など、サービスの検出に影響を与えるには、派生タイプでこのメソッドをオーバーライドできます。</summary>
            <param name="serviceType">検出する Scheduler サービス インターフェイスのタイプ。</param>
            <returns>要求されたサービスを実装するオブジェクト (使用可能な場合)。それ以外の場合は null です。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.StartStopwatch">
            <summary>新しいストップウォッチ オブジェクトを開始します。</summary>
            <returns>新しいストップウォッチ オブジェクト。要求の時点で開始されます。</returns>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.IsEnabled">
            <summary>Scheduler が作業を実行できるかどうかを把握します。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Comparer">
            <summary>絶対時間値の比較に使用される比較を関数取得します。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Clock">
            <summary>Scheduler の絶対時間クロック値を取得します。</summary>
        </member>
        <member name="P:System.Reactive.Concurrency.VirtualTimeSchedulerBase`2.Now">
            <summary>Scheduler の現在時刻の表記を取得します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.#ctor">
            <summary>最初のクロック値として DateTimeOffset の最小値を持つ新しい履歴 Scheduler を作成します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.#ctor(System.DateTimeOffset)">
            <summary>指定された初期クロック値を持つ新しい履歴 Scheduler を作成します。</summary>
            <param name="initialClock">初期クロック値。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.#ctor(System.DateTimeOffset,System.Collections.Generic.IComparer{System.DateTimeOffset})">
            <summary>指定された初期クロック値と絶対時間比較関数を持つ新しい履歴 Scheduler を作成します。</summary>
            <param name="initialClock">クロックの初期値。</param>
            <param name="comparer">絶対時間に基づいてイベントの因果関係を判定する比較関数。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.Add(System.DateTimeOffset,System.TimeSpan)">
            <summary>相対時間値を絶対時間値に追加します。</summary>
            <param name="absolute">絶対時間値。</param>
            <param name="relative">追加する相対時間値。</param>
            <returns>結果の絶対時間合計値。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.ToDateTimeOffset(System.DateTimeOffset)">
            <summary>絶対時間値を DateTimeOffset 値に変換します。</summary>
            <param name="absolute">変換する絶対時間値。</param>
            <returns>対応する DateTimeOffset 値。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalSchedulerBase.ToRelative(System.TimeSpan)">
            <summary>TimeSpan 値を相対時間値に変換します。</summary>
            <param name="timeSpan">変換する TimeSpan 値。</param>
            <returns>対応する相対時間値。</returns>
        </member>
        <member name="T:System.Reactive.Concurrency.HistoricalScheduler">
            <summary>絶対時間では DateTimeOffset、相対時間では TimeSpan を使用する仮想タイム Scheduler を提供します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.#ctor">
            <summary>最初のクロック値として DateTimeOffset の最小値を持つ新しい履歴 Scheduler を作成します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.#ctor(System.DateTimeOffset)">
            <summary>指定された初期クロック値を持つ新しい履歴 Scheduler を作成します。</summary>
            <param name="initialClock">クロックの初期値。</param>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.#ctor(System.DateTimeOffset,System.Collections.Generic.IComparer{System.DateTimeOffset})">
            <summary>指定された初期クロック値を持つ新しい履歴 Scheduler を作成します。</summary>
            <param name="initialClock">クロックの初期値。</param>
            <param name="comparer">絶対時間に基づいてイベントの因果関係を判定する比較関数。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.GetNext">
            <summary>実行される次のスケジュールされた項目を取得します。</summary>
            <returns>次のスケジュールされた項目。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.HistoricalScheduler.ScheduleAbsolute``1(``0,System.DateTimeOffset,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="action">実行するアクション。</param>
            <param name="dueTime">アクションを実行する絶対時間。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Concurrency.VirtualTimeScheduler`2">
            <summary>スケジュールされたアイテムの優先順位キューを使用する仮想時間 Scheduler の基本クラス。</summary>
            <typeparam name="TAbsolute">絶対時間表現タイプ。</typeparam>
            <typeparam name="TRelative">相対時間表現タイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.#ctor">
            <summary>初期クロック値として TAbsolute の既定値を持つ新しい仮想時間 Scheduler を作成します。</summary>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.#ctor(`0,System.Collections.Generic.IComparer{`0})">
            <summary>新しい仮想時間 Scheduler を作成します。</summary>
            <param name="initialClock">クロックの初期値。</param>
            <param name="comparer">絶対時間に基づいてイベントの因果関係を判定する比較関数。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.GetNext">
            <summary>実行される次のスケジュールされた項目を取得します。</summary>
            <returns>次のスケジュールされた項目。</returns>
        </member>
        <member name="M:System.Reactive.Concurrency.VirtualTimeScheduler`2.ScheduleAbsolute``1(``0,`0,System.Func{System.Reactive.Concurrency.IScheduler,``0,System.IDisposable})">
            <summary>dueTime に実行されるアクションをスケジュールします。</summary>
            <typeparam name="TState">スケジュールされたアクションに渡される状態のタイプ。</typeparam>
            <param name="state">実行するアクションに渡される状態。</param>
            <param name="action">実行するアクション。</param>
            <param name="dueTime">アクションを実行する絶対時間。</param>
            <returns>スケジュールされたアクション (ベスト エフォート) を取り消すために使用される破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Subjects.ConnectableObservable`2">
            <summary>基になる監視可能なシーケンスに接続および切断できる監視可能なラッパーを表します。</summary>
            <typeparam name="TSource">ソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TResult">サブジェクトを介して変換した後の、結果的なシーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.ConnectableObservable`2.#ctor(System.IObservable{`0},System.Reactive.Subjects.ISubject{`0,`1})">
            <summary>ソースから接続および切断できる監視可能なオブジェクトを作成します。</summary>
            <param name="source">ラッパーから接続および切断できる、基になる監視可能なソース シーケンス。</param>
            <param name="subject">接続後、基になるソース シーケンスからデータを受け取り、接続可能な監視可能サブジェクトによって公開されるサブジェクト。</param>
        </member>
        <member name="M:System.Reactive.Subjects.ConnectableObservable`2.Connect">
            <summary>監視可能なラッパーをそのソースに接続します。サブスクライブされているすべてのオブザーバーは、接続が確立されている限り、基になる監視可能なシーケンスから値を受け取ります。</summary>
            <returns>監視可能なラッパーをソースから切り離すために使用される破棄可能なオブジェクト。サブスクライブしているオブザーバーは、基になる監視可能なシーケンスからの値の受領を停止します。</returns>
        </member>
        <member name="M:System.Reactive.Subjects.ConnectableObservable`2.Subscribe(System.IObserver{`1})">
            <summary>オブザーバーを監視可能なシーケンスにサブスクライブします。Connect メソッドを介して接続が確立されていなければ、基になる監視可能なソースからの値は受信されません。</summary>
            <param name="observer">現在の ConnectableObservable インスタンスが Connect への呼び出しを介して接続されている場合に、基になる監視可能なソースから値を受け取るオブザーバー。</param>
            <returns>監視可能なシーケンスのサブスクライブ解除に使用される破棄可能。</returns>
        </member>
        <member name="T:System.Reactive.Subjects.Subject">
            <summary>サブジェクトを作成するための一連の静的メソッドを提供します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.Subject.Create``2(System.IObserver{``0},System.IObservable{``1})">
            <summary>指定されたオブザーバーと監視可能なサブジェクトからサブジェクトを作成します。</summary>
            <typeparam name="TSource">オブザーバーが受け取る要素のタイプ。</typeparam>
            <typeparam name="TResult">監視可能なシーケンスによって生成される要素のタイプ。</typeparam>
            <param name="observer">サブジェクトにメッセージを送るために使用されるオブザーバー。</param>
            <param name="observable">サブジェクトから送られたメッセージをサブスクライブするために使用される監視可能なメッセージ。</param>
            <returns>特定のオブザーバーと観察可能を使用して実装されるサブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> または <paramref name="observable"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject.Synchronize``2(System.Reactive.Subjects.ISubject{``0,``1})">
            <summary>サブジェクトに送られたメッセージを同期します。</summary>
            <typeparam name="TSource">サブジェクトが受け取る要素のタイプ。</typeparam>
            <typeparam name="TResult">サブジェクトによって生成される要素のタイプ。</typeparam>
            <param name="subject">同期するサブジェクト。</param>
            <returns>メッセージが同期されているサブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject.Synchronize``2(System.Reactive.Subjects.ISubject{``0,``1},System.Reactive.Concurrency.IScheduler)">
            <summary>サブジェクトに送信されたメッセージを同期し、指定された Scheduler でオブザーバーに通知します。</summary>
            <typeparam name="TSource">サブジェクトが受け取る要素のタイプ。</typeparam>
            <typeparam name="TResult">サブジェクトによって生成される要素のタイプ。</typeparam>
            <param name="subject">同期するサブジェクト。</param>
            <param name="scheduler">オブザーバーに通知する Scheduler。</param>
            <returns>メッセージが同期され、特定の Scheduler でオブザーバーに通知されるサブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="subject"/> または <paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Subjects.AsyncSubject`1">
            <summary>非同期操作の結果を表します。OnCompleted 通知の前の最後の値、または OnError を介して受け取ったエラーは、サブスクライブされたすべてのオブザーバーに送られます。</summary>
            <typeparam name="T">サブジェクトによって処理される要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.#ctor">
            <summary>1 つの値のみを受け取ることができ、今後のすべての監視にキャッシュされるサブジェクトを作成します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnCompleted">
            <summary>シーケンスの終了についてサブスクライブしているすべてのオブザーバーに通知し、最後に受け取ったた値 (該当する場合) も送信されます。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnError(System.Exception)">
            <summary>例外について、サブスクライブしているすべてのオブザーバーに通知します。</summary>
            <param name="error">すべてのオブザーバーに送る例外。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnNext(`0)">
            <summary>サブジェクトに値を送信します。正常な終了前に受け取った最後の値は、サブスクライブされたすべてのオブザーバーおよび将来のオブザーバーに送信されます。</summary>
            <param name="value">サブジェクトに格納する値。</param>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.Subscribe(System.IObserver{`0})">
            <summary>オブザーバーをサブジェクトにサブスクライブします。</summary>
            <param name="observer">サブジェクトにサブスクライブするオブザーバー。</param>
            <returns>サブジェクトからのオブザーバーのサブスクライブ解除に使用できる破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.Dispose">
            <summary>すべてのオブザーバーをサブスクライブ解除し、リソースをリリースします。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.GetAwaiter">
            <summary>現在の AsyncSubject の待機可能なオブジェクトを取得します。</summary>
            <returns>待機できるオブジェクト。</returns>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.OnCompleted(System.Action)">
            <summary>サブジェクトの完了時に呼び出されるコールバック アクションを指定します。</summary>
            <param name="continuation">サブジェクトの完了時に呼び出されるコールバック アクション。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="continuation"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.AsyncSubject`1.GetResult">
            <summary>サブジェクトの最後の要素を取得し、サブジェクトが正常に、または例外的に完了するまでブロックする可能性があります。</summary>
            <returns>サブジェクトの最後の要素。要素を受け取らなかった場合は、InvalidOperationException をスローします。</returns>
            <exception cref="T:System.InvalidOperationException">ソース シーケンスが空です。</exception>
        </member>
        <member name="P:System.Reactive.Subjects.AsyncSubject`1.HasObservers">
            <summary>サブジェクトにサブスクライブしているオブザーバーがあるかどうかを示します。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.AsyncSubject`1.IsCompleted">
            <summary>AsyncSubject が完了したかどうかを取得します。</summary>
        </member>
        <member name="T:System.Reactive.Subjects.BehaviorSubject`1">
            <summary>時間の経過とともに変化する値を表します。オブザーバーは、最後の (または初期) 値と後続のすべての通知を受け取るためにサブスクライブできます。</summary>
            <typeparam name="T">サブジェクトによって処理される要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.#ctor(`0)">
            <summary>最後の値をキャッシュし、指定された値で始まるサブジェクトを作成する <see cref="T:System.Reactive.Subjects.BehaviorSubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="value">サブジェクトが他の値をまだ受け取っていない場合にオブザーバーに送られる初期値。</param>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.OnCompleted">
            <summary>シーケンスの終わりについて、サブスクライブしているすべてのオブザーバーに通知します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.OnError(System.Exception)">
            <summary>例外について、サブスクライブしているすべてのオブザーバーに通知します。</summary>
            <param name="error">すべてのオブザーバーに送る例外。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)">
            <summary>シーケンスで指定された要素の到着について、サブスクライブされたすべてのオブザーバーに通知します。</summary>
            <param name="value">すべてのオブザーバーに送信する値。</param>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.Subscribe(System.IObserver{`0})">
            <summary>オブザーバーをサブジェクトにサブスクライブします。</summary>
            <param name="observer">サブジェクトにサブスクライブするオブザーバー。</param>
            <returns>サブジェクトからのオブザーバーのサブスクライブ解除に使用できる破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.BehaviorSubject`1.Dispose">
            <summary>すべてのオブザーバーをサブスクライブ解除し、リソースをリリースします。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.BehaviorSubject`1.Value">
            <summary>現在の値を取得するか、例外をスローします。</summary>
            <value><see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)"/> が呼び出されるまでコンストラクターに渡される初期値 。その後、最後の値が <see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)"/> に渡されます。</value>
            <remarks>
            <para><see cref="P:System.Reactive.Subjects.BehaviorSubject`1.Value"/> は、<see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnCompleted"/> が呼び出された後に凍結されます。</para>
            <para><see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnError(System.Exception)"/> が呼び出された後は、 <see cref="P:System.Reactive.Subjects.BehaviorSubject`1.Value"/> が指定された例外を常にスローします。 </para>
            <para>例外は常に、<see cref="M:System.Reactive.Subjects.BehaviorSubject`1.Dispose"/> が呼び出された後にスローされます。</para>
            <alert type="caller"><see cref="P:System.Reactive.Subjects.BehaviorSubject`1.Value"/> の読み取りはスレッド セーフな操作ですが、 <see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnNext(`0)"/> または <see cref="M:System.Reactive.Subjects.BehaviorSubject`1.OnError(System.Exception)"/> が同時に呼び出される場合は競合状態になる可能性があります。場合によっては、競合状態を避けるために呼び出し元が外部同期を使用する必要があります。</alert>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">廃棄が呼び出されました。</exception>
        </member>
        <member name="P:System.Reactive.Subjects.BehaviorSubject`1.HasObservers">
            <summary>サブジェクトにサブスクライブしているオブザーバーがあるかどうかを示します。</summary>
        </member>
        <member name="T:System.Reactive.Subjects.Subject`1">
            <summary>監視可能なシーケンスとオブザーバーの双方であるオブジェクトを表します。各通知は、サブスクライブされているすべてのオブザーバーに配信されます。</summary>
            <typeparam name="T">サブジェクトによって処理される要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.#ctor">
            <summary>サブジェクトを作成します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.OnCompleted">
            <summary>シーケンスの終わりについて、サブスクライブしているすべてのオブザーバーに通知します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.OnError(System.Exception)">
            <summary>指定された例外について、サブスクライブされているすべてのオブザーバーに通知します。</summary>
            <param name="error">現在サブスクライブしているすべてのオブザーバーに送信する例外。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.OnNext(`0)">
            <summary>シーケンスで指定された要素の到着について、サブスクライブされたすべてのオブザーバーに通知します。</summary>
            <param name="value">現在サブスクライブしているすべてのオブザーバーに送信する値。</param>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.Subscribe(System.IObserver{`0})">
            <summary>オブザーバーをサブジェクトにサブスクライブします。</summary>
            <param name="observer">サブジェクトにサブスクライブするオブザーバー。</param>
            <returns>サブジェクトからのオブザーバーのサブスクライブ解除に使用できる破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.Subject`1.Dispose">
            <summary><see cref="T:System.Reactive.Subjects.Subject`1"/> クラスの現在のインスタンスで使用されているすべてのリソースをリリース し、すべてのオブザーバーのサブスクライブを解除します。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.Subject`1.HasObservers">
            <summary>サブジェクトにサブスクライブしているオブザーバーがあるかどうかを示します。</summary>
        </member>
        <member name="T:System.Reactive.Joins.Pattern">
            <summary>結合パターンの抽象基本クラス。</summary>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`1">
            <summary>1 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`1.Then``1(System.Func{`0,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`2">
            <summary>2 つの観測可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`2.And``1(System.IObservable{``0})">
            <summary>3 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource3">3 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 2 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`2.Then``1(System.Func{`0,`1,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`3">
            <summary>3 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`3.And``1(System.IObservable{``0})">
            <summary>4 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource4">4 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 3 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`3.Then``1(System.Func{`0,`1,`2,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`4">
            <summary>4 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`4.And``1(System.IObservable{``0})">
            <summary>5 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource5">5 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 4 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`4.Then``1(System.Func{`0,`1,`2,`3,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`5">
            <summary>5 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`5.And``1(System.IObservable{``0})">
            <summary>6 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource6">6 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 5 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`5.Then``1(System.Func{`0,`1,`2,`3,`4,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`6">
            <summary>6 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`6.And``1(System.IObservable{``0})">
            <summary>7 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource7">7 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 6 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`6.Then``1(System.Func{`0,`1,`2,`3,`4,`5,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`7">
            <summary>7 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`7.And``1(System.IObservable{``0})">
            <summary>8 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource8">8 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 7 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`7.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`8">
            <summary>8 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`8.And``1(System.IObservable{``0})">
            <summary>9 つの監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource9">9 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 8 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`8.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`9">
            <summary>9 つの監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`9.And``1(System.IObservable{``0})">
            <summary>10 個の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource10">10 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 9 つのシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`9.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`10">
            <summary>10 個の監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`10.And``1(System.IObservable{``0})">
            <summary>11 個の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource11">11 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 10 個のシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`10.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`11">
            <summary>11 個の監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`11.And``1(System.IObservable{``0})">
            <summary>12 個の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource12">12 番目の監視可能シーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 11 個のシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`11.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`12">
            <summary>12 個の監視可能なシーケンスに対する結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`12.And``1(System.IObservable{``0})">
            <summary>13 の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource13">13 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 12 個のシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`12.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`13">
            <summary>13 の監視可能なシーケンスに対する結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`13.And``1(System.IObservable{``0})">
            <summary>14 個の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource14">14 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">前の 13 のシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`13.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`14">
            <summary>14 個の監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`14.And``1(System.IObservable{``0})">
            <summary>15 個の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource15">15 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">14 個の前のシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`14.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`15">
            <summary>15 個の監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource15">15 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`15.And``1(System.IObservable{``0})">
            <summary>16 個の監視可能なシーケンスすべてに使用可能な要素がある場合に一致するパターンを作成します。</summary>
            <typeparam name="TSource16">16 番目の監視可能なシーケンス内の要素のタイプ。</typeparam>
            <param name="other">15 の前のシーケンスと一致する監視可能なシーケンス。</param>
            <returns>すべての監視可能なシーケンスに使用可能な要素がある場合に一致するパターン オブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`15.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Pattern`16">
            <summary>16 個の監視可能なシーケンス上の結合パターンを表します。</summary>
            <typeparam name="TSource1">最初のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource2">2 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource3">3 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource4">4 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource5">5 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource6">6 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource7">7 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource8">8 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource9">9 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource10">10 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource11">11 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource12">12 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource13">13 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource14">14 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource15">15 番目のソース シーケンス内の要素のタイプ。</typeparam>
            <typeparam name="TSource16">16 番目のソース シーケンス内の要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Joins.Pattern`16.Then``1(System.Func{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15,``0})">
            <summary>すべての監視可能なシーケンスに使用可能な要素がある場合に一致し、選択関数を呼び出して要素を投入します。</summary>
            <typeparam name="TResult">選択関数によって返される結果シーケンス内の要素のタイプ。</typeparam>
            <param name="selector">ソース シーケンス内の要素に対して呼び出されるセレクター。</param>
            <returns>When 演算子に (他の計画と共に) 供給され、予測結果を生成する計画。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="selector"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.Joins.Plan`1">
            <summary>結合パターンの実行計画を表します。</summary>
            <typeparam name="TResult">計画によって生成される結果のタイプ。</typeparam>
        </member>
        <member name="T:System.Reactive.Subjects.ReplaySubject`1">
            <summary>監視可能なシーケンスとオブザーバーの双方であるオブジェクトを表します。各通知は、バッファー トリミング ポリシーの対象となる、サブスクライブしているすべてのオブザーバーおよび将来のオブザーバーに配信されます。</summary>
            <typeparam name="T">サブジェクトによって処理される要素のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32,System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定されたバッファー サイズ、ウィンドウ、Scheduler のある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <param name="scheduler">オブザーバーが呼び出される Scheduler。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。-または- <paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32,System.TimeSpan)">
            <summary>指定されたバッファー サイズとウィンドウのある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="window">再生バッファーの最大時間長。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。-または- <paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor">
            <summary><see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Reactive.Concurrency.IScheduler)">
            <summary>指定された Scheduler のある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="scheduler">オブザーバーが呼び出される Scheduler。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32,System.Reactive.Concurrency.IScheduler)">
            <summary>指定されたバッファー サイズと Scheduler のある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <param name="scheduler">オブザーバーが呼び出される Scheduler。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.Int32)">
            <summary>指定されたバッファー サイズのある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="bufferSize">再生バッファーの最大要素数。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize"/> は 0 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.TimeSpan,System.Reactive.Concurrency.IScheduler)">
            <summary>指定されたウィンドウと Scheduler のある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="window">再生バッファーの最大時間長。</param>
            <param name="scheduler">オブザーバーが呼び出される Scheduler。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="scheduler"/> は null です。</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.#ctor(System.TimeSpan)">
            <summary>指定されたウィンドウのある <see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの新しいインスタンスを初期化します。</summary>
            <param name="window">再生バッファーの最大時間長。</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="window"/> は TimeSpan.Zero 未満です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.OnNext(`0)">
            <summary>シーケンス内の指定された要素の到着について、サブスクライブしているすべてのオブザーバーと将来のオブザーバーに通知します。</summary>
            <param name="value">すべてのオブザーバーに送信する値。</param>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.OnError(System.Exception)">
            <summary>指定された例外について、すべてのサブスクライブしているオブザーバーと将来のオブザーバーに通知します。</summary>
            <param name="error">すべてのオブザーバーに送る例外。</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="error"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.OnCompleted">
            <summary>シーケンスの終了について、すべてのサブスクライブしているオブザーバーと将来のオブザーバーに通知します。</summary>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.Subscribe(System.IObserver{`0})">
            <summary>オブザーバーをサブジェクトにサブスクライブします。</summary>
            <param name="observer">サブジェクトにサブスクライブするオブザーバー。</param>
            <returns>サブジェクトからのオブザーバーのサブスクライブ解除に使用できる破棄可能なオブジェクト。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observer"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Subjects.ReplaySubject`1.Dispose">
            <summary><see cref="T:System.Reactive.Subjects.ReplaySubject`1"/> クラスの現在のインスタンスで使用されているすべてのリソースをリリースし、すべてのオブザーバーのサブスクライブを解除します。</summary>
        </member>
        <member name="P:System.Reactive.Subjects.ReplaySubject`1.HasObservers">
            <summary>サブジェクトにサブスクライブしているオブザーバーがあるかどうかを示します。</summary>
        </member>
        <member name="T:System.Reactive.Threading.Tasks.NamespaceDoc">
            <summary><b>System.Reactive.Threading.Tasks</b> 名前空間には、タスクと監視可能なシーケンス間の変換用のヘルパーが含まれています。 </summary>
        </member>
        <member name="T:System.Reactive.Threading.Tasks.TaskObservableExtensions">
            <summary>タスクを監視可能なシーケンスに変換するための一連の静的メソッドを提供します。</summary>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable(System.Threading.Tasks.Task)">
            <summary>タスクの完了を知らせる監視可能なシーケンスを返します。</summary>
            <param name="task">監視可能なシーケンスに変換するタスク。</param>
            <returns>タスクが完了したときに単位値を生成する、またはタスクによって生成された例外を伝達する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="task"/> は null です。</exception>
            <remarks>指定されたタスク オブジェクトが取り消しをサポートしている場合は、その代わりに <see cref="M:System.Reactive.Linq.Observable.FromAsync(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})"/> を使用することを検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToObservable``1(System.Threading.Tasks.Task{``0})">
            <summary>タスクの結果を伝達する監視可能なシーケンスを返します。</summary>
            <typeparam name="TResult">タスクによって生成される結果のタイプ。</typeparam>
            <param name="task">監視可能なシーケンスに変換するタスク。</param>
            <returns>タスクの結果を生成する、またはタスクによって生成された例外を伝達する監視可能なシーケンス。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="task"/> は null です。</exception>
            <remarks>指定されたタスク オブジェクトが取り消しをサポートしている場合は、その代わりに <see cref="M:System.Reactive.Linq.Observable.FromAsync``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}})"/> を使用することを検討してください。</remarks>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0})">
            <summary>最後の値または監視可能なシーケンスによって生成された例外を受け取るタスクを返します。</summary>
            <typeparam name="TResult">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="observable">タスクに変換する監視可能なシーケンス。</param>
            <returns>最後の要素または監視可能なシーケンスによって生成された例外を受け取るタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0},System.Object)">
            <summary>最後の値または監視可能なシーケンスによって生成された例外を受け取るタスクを返します。</summary>
            <typeparam name="TResult">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="observable">タスクに変換する監視可能なシーケンス。</param>
            <param name="state">基になるタスクの AsyncState として使用する状態。</param>
            <returns>最後の要素または監視可能なシーケンスによって生成された例外を受け取るタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0},System.Threading.CancellationToken)">
            <summary>最後の値または監視可能なシーケンスによって生成された例外を受け取るタスクを返します。</summary>
            <typeparam name="TResult">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="observable">タスクに変換する監視可能なシーケンス。</param>
            <param name="cancellationToken">タスクの取り消しに使用できるキャンセル トークン。監視可能なシーケンスからサブスクリプションが解除されます。</param>
            <returns>最後の要素または監視可能なシーケンスによって生成された例外を受け取るタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> は null です。</exception>
        </member>
        <member name="M:System.Reactive.Threading.Tasks.TaskObservableExtensions.ToTask``1(System.IObservable{``0},System.Threading.CancellationToken,System.Object)">
            <summary>最後の値または監視可能なシーケンスによって生成された例外を受け取るタスクを返します。</summary>
            <typeparam name="TResult">ソース シーケンス内の要素のタイプ。</typeparam>
            <param name="observable">タスクに変換する監視可能なシーケンス。</param>
            <param name="cancellationToken">タスクの取り消しに使用できるキャンセル トークン。監視可能なシーケンスからサブスクリプションが解除されます。</param>
            <param name="state">基になるタスクの AsyncState として使用する状態。</param>
            <returns>最後の要素または監視可能なシーケンスによって生成された例外を受け取るタスク。</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="observable"/> は null です。</exception>
        </member>
        <member name="T:System.Reactive.TimeInterval`1">
            <summary>時間間隔情報に関連付けられた値を表します。時間間隔は、値の生成にかかった時間、前の値に対する間隔、ベースに対する値の配信時間などを表すことができます。</summary>
            <typeparam name="T">時間間隔情報で注釈を付けられる値のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.#ctor(`0,System.TimeSpan)">
            <summary>時間間隔値を構築します。</summary>
            <param name="value">時間間隔で注釈を付ける値。</param>
            <param name="interval">値に関連付けられた時間間隔。</param>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.Equals(System.Reactive.TimeInterval{`0})">
            <summary>現在の TimeInterval&lt;T&gt; 値に、指定された TimeInterval&lt;T&gt; 値と同じ Value および Interval があるかどうかを判定します。</summary>
            <param name="other">現在の TimeInterval&lt;T&gt; 値と比較するオブジェクト。</param>
            <returns>TimeInterval&lt;T&gt; 値の両方で Value と Interval が同じ場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.op_Equality(System.Reactive.TimeInterval{`0},System.Reactive.TimeInterval{`0})">
            <summary>指定された 2 つの TimeInterval&lt;T&gt; 値の Value と Interval が同じかどうかを判定します。</summary>
            <param name="first">比較する最初の TimeInterval&lt;T&gt; 値。</param>
            <param name="second">比較する 2 番目の TimeInterval&lt;T&gt; 値。</param>
            <returns>最初の TimeInterval&lt;T&gt; 値の Value と Interval が 2 番目の TimeInterval&lt;T&gt; 値と同じ場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.op_Inequality(System.Reactive.TimeInterval{`0},System.Reactive.TimeInterval{`0})">
            <summary>指定された 2 つの TimeInterval&lt;T&gt; 値に同じ Value と Interval がないかどうかを判定します。</summary>
            <param name="first">比較する最初の TimeInterval&lt;T&gt; 値。</param>
            <param name="second">比較する 2 番目の TimeInterval&lt;T&gt; 値。</param>
            <returns>最初の TimeInterval&lt;T&gt; 値の Value または Interval が 2 番目の TimeInterval&lt;T&gt; 値とは異なる場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.Equals(System.Object)">
            <summary>指定された System.Object が現在の TimeInterval&lt;T&gt; と等しいかどうかを判定します。</summary>
            <param name="obj">現在の TimeInterval&lt;T&gt; と比較する System.Object.</param>
            <returns>指定された System.Object が現在の TimeInterval&lt;T&gt; と等しい場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.GetHashCode">
            <summary>現在の TimeInterval&lt;/T&gt; 値のハッシュ コードを返します。</summary>
            <returns>現在の TimeInterval&lt;T&gt;値のハッシュ コード。</returns>
        </member>
        <member name="M:System.Reactive.TimeInterval`1.ToString">
            <summary>現在の TimeInterval&lt;T&gt; 値の文字列表現を返します。</summary>
            <returns>現在の TimeInterval&lt;T&gt;値の文字列表現。</returns>
        </member>
        <member name="P:System.Reactive.TimeInterval`1.Value">
            <summary>値を取得します。</summary>
        </member>
        <member name="P:System.Reactive.TimeInterval`1.Interval">
            <summary>間隔を取得します。</summary>
        </member>
        <member name="T:System.Reactive.Timestamped`1">
            <summary>タイムスタンプのある値を表します。タイムスタンプは通常、IScheduler のクロックを使用して現在の時刻を取得し、値を受け取った時刻を表します。</summary>
            <typeparam name="T">タイムスタンプが付けられた値のタイプ。</typeparam>
        </member>
        <member name="M:System.Reactive.Timestamped`1.#ctor(`0,System.DateTimeOffset)">
            <summary>タイムスタンプ付きの値を作成します。</summary>
            <param name="value">タイムスタンプで注釈を付ける値。</param>
            <param name="timestamp">値に関連付けられたタイムスタンプ。</param>
        </member>
        <member name="M:System.Reactive.Timestamped`1.Equals(System.Reactive.Timestamped{`0})">
            <summary>現在の Timestamped&lt;T&gt; 値に、指定された Timestamped&lt;T&gt; 値と同じ Value と Timestamp があるかどうかを判定します。</summary>
            <param name="other">現在の Timestamped&lt;T&gt; 値と比較するオブジェクト。</param>
            <returns>両方の Timestamped&lt;T&gt; 値の Value と Timestamp が同じ場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.op_Equality(System.Reactive.Timestamped{`0},System.Reactive.Timestamped{`0})">
            <summary>指定された 2 つの Timestamped&lt;T&gt;値の Value と Timestamp が同じかどうかを判定します。</summary>
            <param name="first">比較する最初の Timestamped&lt;T&gt; 値。</param>
            <param name="second">比較する 2 番目の Timestamped&lt;T&gt; 値。</param>
            <returns>最初の Timestamped&lt;T&gt; 値の Value と Timestamp が 2 番目の Timestamped&lt;T&gt; 値と同じ場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.op_Inequality(System.Reactive.Timestamped{`0},System.Reactive.Timestamped{`0})">
            <summary>指定された 2 つの Timestamped&lt;T&gt;値に同じ Value と Timestamp がないかどうかを判定します。</summary>
            <param name="first">比較する最初の Timestamped&lt;T&gt; 値。</param>
            <param name="second">比較する 2 番目の Timestamped&lt;T&gt; 値。</param>
            <returns>最初の Timestamped&lt;T&gt; 値の Value または Timestamp が 2 番目の Timestamped&lt;T&gt;  値とは異なる場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.Equals(System.Object)">
            <summary>指定された System.Object が現在の Timestamped&lt;T&gt; に等しいかどうかを判定します。</summary>
            <param name="obj">現在の Timestamped&lt;T&gt; と比較する System.Object。</param>
            <returns>指定された System.Object が現在の Timestamped&lt;T&gt; に等しい場合は true、それ以外の場合は false です。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.GetHashCode">
            <summary>現在の Timestamped&lt;T&gt; 値のハッシュ コードを返します。</summary>
            <returns>現在の Timestamped&lt;T&gt; 値のハッシュ コード。</returns>
        </member>
        <member name="M:System.Reactive.Timestamped`1.ToString">
            <summary>現在の Timestamped&lt;T&gt; 値の文字列表現を返します。</summary>
            <returns>現在の Timestamped&lt;T&gt; 値の文字列表現。</returns>
        </member>
        <member name="P:System.Reactive.Timestamped`1.Value">
            <summary>値を取得します。</summary>
        </member>
        <member name="P:System.Reactive.Timestamped`1.Timestamp">
            <summary>タイムスタンプを取得します。</summary>
        </member>
        <member name="T:System.Reactive.Timestamped">
            <summary>Timestamped&lt;T&gt; インスタンスを作成するためのファクトリ メソッドを持つヘルパー クラス。</summary>
        </member>
        <member name="M:System.Reactive.Timestamped.Create``1(``0,System.DateTimeOffset)">
            <summary>Timestamped&lt;T&gt; のインスタンスを作成します。&lt;/T&gt;これは、タイプの推定を使用してコンストラクター呼び出しでタイプを指定しないようにする糖衣構文で、匿名タイプを使用する場合に非常に便利です。</summary>
            <param name="value">タイムスタンプで注釈を付ける値。</param>
            <param name="timestamp">値に関連付けられたタイムスタンプ。</param>
            <returns>新しいタイムスタンプの付いた値を作成します。</returns>
        </member>
        <member name="T:System.Reactive.Strings_Linq">
            <summary>ローカライズされた文字列などを検索するために厳密にタイプ指定されたリソース クラス。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.ResourceManager">
            <summary>このクラスで使用されるキャッシュされた ResourceManager インスタンスを返します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.Culture">
            <summary>この厳密にタイプ指定されたリソース クラスを使用するすべてのリソース検索に対して、現在のスレッドの CurrentUICulture プロパティをオーバーライドします。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.COULD_NOT_FIND_INSTANCE_EVENT">
            <summary>「&apos;{1}&apos; タイプのオブジェクトでイベント &apos;{0}&apos; が見つかりませんでした。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.COULD_NOT_FIND_STATIC_EVENT">
            <summary>「&apos;{1}&apos; タイプでイベント &apos;{0}&apos; が見つかりませんでした」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_ADD_METHOD_SHOULD_TAKE_ONE_PARAMETER">
            <summary>「Add メソッドではパラメーターが 1 個必要です。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_ARGS_NOT_ASSIGNABLE">
            <summary>「イベント デリゲートの 2 番目のパラメーターは &apos;{0}&apos; に割り当てる必要があります。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_MISSING_ADD_METHOD">
            <summary>「イベントには add メソッドがありません。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_MISSING_REMOVE_METHOD">
            <summary>「イベントには remove メソッドがありません。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_MUST_RETURN_VOID">
            <summary>「イベント デリゲートには void の戻り値のタイプが必要です。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_PATTERN_REQUIRES_TWO_PARAMETERS">
            <summary>「イベント デリゲートには正確に 2 つのパラメーターが必要です。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_REMOVE_METHOD_SHOULD_TAKE_ONE_PARAMETER">
            <summary>「Remove メソッドではパラメーターが 1 個必要です。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_SENDER_NOT_ASSIGNABLE">
            <summary>「イベント デリゲートの最初のパラメーターは &apos;{0}&apos; に割り当てる必要があります。」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.EVENT_WINRT_REMOVE_METHOD_SHOULD_TAKE_ERT">
            <summary>「WinRT イベントの Remove メソッドは EventRegistrationToken が必要です」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.MORE_THAN_ONE_ELEMENT">
            <summary>「シーケンスには複数の要素が含まれています」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.MORE_THAN_ONE_MATCHING_ELEMENT">
            <summary>「シーケンスには一致する要素が複数含まれています」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.NO_ELEMENTS">
            <summary>「シーケンスに要素は含まれていません」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.NO_MATCHING_ELEMENTS">
            <summary>「シーケンスには一致する要素が含まれていません」に似たローカライズされた文字列を検索します。</summary>
        </member>
        <member name="P:System.Reactive.Strings_Linq.CANT_ADVANCE_WHILE_RUNNING">
            <summary>「Scheduler がすでに実行中の場合、{0} は呼び出せません。代わりに Sleep を使用してみてください。」に似たローカライズされた文字列を検索します。</summary>
        </member>
    </members>
</doc>